[{"path":"/home/u93631/A10_oneapi/IOpipe/src/FakeIOPipes.hpp", "name":"FakeIOPipes.hpp", "has_active_debug_locs":false, "absName":"/home/u93631/A10_oneapi/IOpipe/src/FakeIOPipes.hpp", "content":"#ifndef __FAKEIOPIPES_HPP__\u000A#define __FAKEIOPIPES_HPP__\u000A\u000A#include <iostream>\u000A#include <type_traits>\u000A#include <utility>\u000A\u000A#include <CL/sycl.hpp>\u000A#include <sycl/ext/intel/fpga_extensions.hpp>\u000A\u000A// the \"detail\" namespace is commonly used in C++ as an internal namespace\u000A// (to a file) that is not meant to be visible to the public and should be\u000A// ignored by external users. That is to say, you should never have the line:\u000A// \"using namespace detail;\" in your code!\u000A//\u000A// \"internal\" is another common name for a namespace like this.\u000Anamespace detail {\u000A\u000Ausing namespace sycl;\u000A\u000Atemplate <typename ID, typename T, bool use_host_alloc>\u000Aclass ProducerConsumerBaseImpl {\u000A protected:\u000A  // private members\u000A  static inline T *host_data_{nullptr};\u000A  static inline T *device_data_{nullptr};\u000A  static inline size_t count_{};\u000A  static inline bool initialized_{false};\u000A\u000A  // use some fancy C++ metaprogramming to get the correct pointer type\u000A  // based on the template variable\u000A  typedef\u000A      typename std::conditional_t<use_host_alloc, host_ptr<T>, device_ptr<T>>\u000A          kernel_ptr_type;\u000A\u000A  // private constructor so users cannot make an object\u000A  ProducerConsumerBaseImpl(){};\u000A\u000A  static T *get_kernel_ptr() {\u000A    return use_host_alloc ? host_data_ : device_data_;\u000A  }\u000A\u000A  static void initialized_check() {\u000A    if (!initialized_) {\u000A      std::cerr << \"ERROR: Init() has not been called\\n\";\u000A      std::terminate();\u000A    }\u000A  }\u000A\u000A public:\u000A  // disable copy constructor and operator=\u000A  ProducerConsumerBaseImpl(const ProducerConsumerBaseImpl &) = delete;\u000A  ProducerConsumerBaseImpl &operator=(ProducerConsumerBaseImpl const &) =\u000A      delete;\u000A\u000A  static void Init(queue &q, size_t count) {\u000A    // make sure init hasn't already been called\u000A    if (initialized_) {\u000A      std::cerr << \"ERROR: Init() was already called\\n\";\u000A      std::terminate();\u000A    }\u000A\u000A    // track count\u000A    count_ = count;\u000A\u000A    // check for USM support\u000A    device d = q.get_device();\u000A    if (!d.get_info<info::device::usm_host_allocations>() && use_host_alloc) {\u000A      std::cerr << \"ERROR: The selected device does not support USM host\"\u000A                << \" allocations\\n\";\u000A      std::terminate();\u000A    }\u000A    if (!d.get_info<info::device::usm_device_allocations>()) {\u000A      std::cerr << \"ERROR: The selected device does not support USM device\"\u000A                << \" allocations\\n\";\u000A      std::terminate();\u000A    }\u000A\u000A    // Allocate the space the user requested. Calling a different malloc\u000A    // based on whether the user wants to use USM host allocations or not.\u000A    if (use_host_alloc) {\u000A      host_data_ = malloc_host<T>(count_, q);\u000A    } else {\u000A      host_data_ = new T[count_];\u000A    }\u000A\u000A    if (host_data_ == nullptr) {\u000A      std::cerr << \"ERROR: failed to allocate space for host_data_\\n\";\u000A      std::terminate();\u000A    }\u000A\u000A    // if not using host allocations, allocate device memory\u000A    if (!use_host_alloc) {\u000A      device_data_ = malloc_device<T>(count_, q);\u000A      if (device_data_ == nullptr) {\u000A        std::cerr << \"ERROR: failed to allocate space for\"\u000A                  << \"device_data_\\n\";\u000A        std::terminate();\u000A      }\u000A    }\u000A\u000A    initialized_ = true;\u000A  }\u000A\u000A  static void Destroy(queue &q) {\u000A    initialized_check();\u000A\u000A    // free memory depending on 'use_host_alloc' flag\u000A    if (use_host_alloc) {\u000A      // free USM host allocation\u000A      sycl::free(host_data_, q);\u000A    } else {\u000A      // free C++ allocated memory\u000A      delete[] host_data_;\u000A\u000A      // free USM device allocation\u000A      sycl::free(device_data_, q);\u000A    }\u000A\u000A    initialized_ = false;\u000A  }\u000A\u000A  static size_t Count() {\u000A    initialized_check();\u000A    return count_;\u000A  }\u000A\u000A  static T *Data() {\u000A    initialized_check();\u000A    return host_data_;\u000A  }\u000A};\u000A\u000A////////////////////////////////////////////////////////////////////////////////\u000A// Producer implementation\u000Atemplate <typename Id, typename T, bool use_host_alloc, size_t min_capacity>\u000Aclass ProducerImpl : public ProducerConsumerBaseImpl<Id, T, use_host_alloc> {\u000A private:\u000A  // base implementation alias\u000A  using BaseImpl = ProducerConsumerBaseImpl<Id, T, use_host_alloc>;\u000A  using kernel_ptr_type = typename BaseImpl::kernel_ptr_type;\u000A\u000A  // IDs for the pipe and kernel\u000A  class PipeID;\u000A  class KernelID;\u000A\u000A  // private constructor so users cannot make an object\u000A  ProducerImpl(){};\u000A\u000A public:\u000A  // disable copy constructor and operator=\u000A  ProducerImpl(const ProducerImpl &) = delete;\u000A  ProducerImpl &operator=(ProducerImpl const &) = delete;\u000A\u000A  // the pipe to connect to in device code\u000A  using Pipe = sycl::ext::intel::pipe<PipeID, T, min_capacity>;\u000A\u000A  // the implementation of the static\u000A  static std::pair<event, event> Start(queue &q,\u000A                                       size_t count = BaseImpl::count_) {\u000A    // make sure initialized has been called\u000A    BaseImpl::initialized_check();\u000A\u000A    // can't produce more data than exists\u000A    if (count > BaseImpl::count_) {\u000A      std::cerr << \"ERROR: Start() called with count=\" << count\u000A                << \" but allocated size is \" << BaseImpl::count_ << \"\\n\";\u000A      std::terminate();\u000A    }\u000A\u000A    // If we aren't using USM host allocations, must transfer memory to device\u000A    event dma_event;\u000A    if (!use_host_alloc) {\u000A      dma_event = q.memcpy(BaseImpl::device_data_, BaseImpl::host_data_,\u000A                           BaseImpl::count_ * sizeof(T));\u000A    }\u000A\u000A    // pick the right pointer to pass to the kernel\u000A    auto kernel_ptr = BaseImpl::get_kernel_ptr();\u000A\u000A    // launch the kernel (use event.depends_on to wait on the memcpy)\u000A    auto kernel_event = q.submit([&](handler &h) {\u000A      // the kernel must wait until the DMA transfer is done before launching\u000A      // this will only take affect it we actually performed the DMA above\u000A      h.depends_on(dma_event);\u000A\u000A      // the producing kernel\u000A      // NO-FORMAT comments are for clang-format\u000A      h.single_task<Id>([=\u000A      ]() [[intel::kernel_args_restrict]] {  // NO-FORMAT: Attribute\u000A        kernel_ptr_type ptr(kernel_ptr);\u000A        for (size_t i = 0; i < count; i++) {\u000A          auto d = *(ptr + i);\u000A          Pipe::write(d);\u000A        }\u000A      });\u000A    });\u000A\u000A    return std::make_pair(dma_event, kernel_event);\u000A  }\u000A};\u000A////////////////////////////////////////////////////////////////////////////////\u000A\u000A////////////////////////////////////////////////////////////////////////////////\u000A// Consumer implementation\u000Atemplate <typename Id, typename T, bool use_host_alloc, size_t min_capacity>\u000Aclass ConsumerImpl : public ProducerConsumerBaseImpl<Id, T, use_host_alloc> {\u000A private:\u000A  // base implementation alias\u000A  using BaseImpl = ProducerConsumerBaseImpl<Id, T, use_host_alloc>;\u000A  using kernel_ptr_type = typename BaseImpl::kernel_ptr_type;\u000A\u000A  // IDs for the pipe and kernel\u000A  class PipeID;\u000A  class KernelID;\u000A\u000A  // private constructor so users cannot make an object\u000A  ConsumerImpl(){};\u000A\u000A public:\u000A  // disable copy constructor and operator=\u000A  ConsumerImpl(const ConsumerImpl &) = delete;\u000A  ConsumerImpl &operator=(ConsumerImpl const &) = delete;\u000A\u000A  // the pipe to connect to in device code\u000A  using Pipe = sycl::ext::intel::pipe<PipeID, T, min_capacity>;\u000A\u000A  static std::pair<event, event> Start(queue &q,\u000A                                       size_t count = BaseImpl::count_) {\u000A    // make sure initialized has been called\u000A    BaseImpl::initialized_check();\u000A\u000A    // can't produce more data than exists\u000A    if (count > BaseImpl::count_) {\u000A      std::cerr << \"ERROR: Start() called with count=\" << count\u000A                << \" but allocated size is \" << BaseImpl::count_ << \"\\n\";\u000A      std::terminate();\u000A    }\u000A\u000A    // pick the right pointer to pass to the kernel\u000A    auto kernel_ptr = BaseImpl::get_kernel_ptr();\u000A\u000A    // launch the kernel to read the output into device side global memory\u000A    auto kernel_event = q.submit([&](handler &h) {\u000A      // NO-FORMAT comments are for clang-format\u000A      h.single_task<Id>([=\u000A      ]() [[intel::kernel_args_restrict]] {  // NO-FORMAT: Attribute\u000A        kernel_ptr_type ptr(kernel_ptr);\u000A        for (size_t i = 0; i < count; i++) {\u000A          auto d = Pipe::read();\u000A          *(ptr + i) = d;\u000A        }\u000A      });\u000A    });\u000A\u000A    // if the user wanted to use board memory, copy the data back to the host\u000A    event dma_event;\u000A    if (!use_host_alloc) {\u000A      // launch a task to copy the data back from the device. Use the\u000A      // event.depends_on signal to wait for the kernel to finish first.\u000A      dma_event = q.submit([&](handler &h) {\u000A        h.depends_on(kernel_event);\u000A        h.memcpy(BaseImpl::host_data_, BaseImpl::device_data_,\u000A                 BaseImpl::count_ * sizeof(T));\u000A      });\u000A    }\u000A\u000A    return std::make_pair(dma_event, kernel_event);\u000A  }\u000A};\u000A////////////////////////////////////////////////////////////////////////////////\u000A\u000A}  // namespace detail\u000A\u000A// alias the implementations to face the user\u000Atemplate <typename Id, typename T, bool use_host_alloc, size_t min_capacity = 0>\u000Ausing Producer = detail::ProducerImpl<Id, T, use_host_alloc, min_capacity>;\u000A\u000Atemplate <typename Id, typename T, bool use_host_alloc, size_t min_capacity = 0>\u000Ausing Consumer = detail::ConsumerImpl<Id, T, use_host_alloc, min_capacity>;\u000A\u000A// convenient aliases to get a host or device allocation producer/consumer\u000Atemplate <typename Id, typename T, size_t min_capacity = 0>\u000Ausing HostConsumer = Consumer<Id, T, true, min_capacity>;\u000A\u000Atemplate <typename Id, typename T, size_t min_capacity = 0>\u000Ausing DeviceConsumer = Consumer<Id, T, false, min_capacity>;\u000A\u000Atemplate <typename Id, typename T, size_t min_capacity = 0>\u000Ausing HostProducer = Producer<Id, T, true, min_capacity>;\u000A\u000Atemplate <typename Id, typename T, size_t min_capacity = 0>\u000Ausing DeviceProducer = Producer<Id, T, false, min_capacity>;\u000A\u000A#endif /* __FAKEIOPIPES_HPP__ */\u000A"}, {"path":"/home/u93631/A10_oneapi/IOpipe/src/HostSideChannel.hpp", "name":"HostSideChannel.hpp", "has_active_debug_locs":false, "absName":"/home/u93631/A10_oneapi/IOpipe/src/HostSideChannel.hpp", "content":"#ifndef __HOSTSIDECHANNEL_HPP__\u000A#define __HOSTSIDECHANNEL_HPP__\u000A\u000A#include <iostream>\u000A#include <type_traits>\u000A\u000A#include <CL/sycl.hpp>\u000A#include <sycl/ext/intel/fpga_extensions.hpp>\u000A\u000A#include \"FakeIOPipes.hpp\"\u000A\u000Ausing namespace sycl;\u000A\u000A//\u000A// This class provides a convenient, but low-bandwidth and relatively high\u000A// latency, side channel to send data from the host to the device. It exposes\u000A// a read() interface to the DEVICE code that the user can treat just like a\u000A// SYCL pipe. It also exposes a write interface to the HOST that allows the\u000A// user to easily write data from host to the device\u000A//\u000Atemplate <typename Id, typename T, bool use_host_alloc, size_t min_capacity=0>\u000Aclass HostToDeviceSideChannel {\u000Aprotected:\u000A  using MyProducer = Producer<Id, T, use_host_alloc, min_capacity>;\u000A  static inline queue* q_{nullptr};\u000A\u000Apublic:\u000A  // disable copy constructor and operator=\u000A  HostToDeviceSideChannel()=delete;\u000A  HostToDeviceSideChannel(const HostToDeviceSideChannel &)=delete;\u000A  HostToDeviceSideChannel& operator=(HostToDeviceSideChannel const &)=delete;\u000A\u000A  static void Init(queue &q) {\u000A    q_ = &q;\u000A    MyProducer::Init(q, 1);\u000A  };\u000A\u000A  static void Destroy(queue &q) {\u000A    q_ = nullptr;\u000A    MyProducer::Destroy(q);\u000A  };\u000A\u000A  static T read() {\u000A    // DEVICE CODE\u000A    return MyProducer::Pipe::read();\u000A  }\u000A\u000A  static T read(bool &success_code) {\u000A    // DEVICE CODE\u000A    return MyProducer::Pipe::read(success_code);\u000A  }\u000A\u000A  // blocking\u000A  static void write(const T &data) {\u000A    // HOST CODE\u000A    // populate the data\u000A    MyProducer::Data()[0] = data;\u000A\u000A    // start the kernel and wait on it to finish (blocking)\u000A    event dma, kernel;\u000A    std::tie(dma, kernel) = MyProducer::Start(*q_);\u000A    dma.wait();\u000A    kernel.wait();\u000A  }\u000A\u000A  // non-blocking\u000A  // Call .wait() on the returned event to wait for the write to take place\u000A  static event write(const T &data, bool &success_code) {\u000A    // HOST CODE\u000A    // always succeed\u000A    success_code = true;\u000A\u000A    // populate the data\u000A    MyProducer::Data()[0] = data;\u000A\u000A    // start the kernel and return the kernel event\u000A    return MyProducer::Start(*q_).second;\u000A  }\u000A};\u000A\u000A//\u000A// This class provides a convenient, but not highly performing, side channel\u000A// to send data from the device to the host. It exposes a read() interface\u000A// to the HOST code that lets the user get updates from the device.\u000A// It also exposes a write interface to the DEVICE that allows the user to\u000A// easily write data from device to the host.\u000A//\u000Atemplate <typename Id, typename T, bool use_host_alloc, size_t min_capacity=0>\u000Aclass DeviceToHostSideChannel {\u000Aprotected:\u000A  using MyConsumer = Consumer<Id, T, use_host_alloc, min_capacity>;\u000A  static inline queue* q_{nullptr};\u000A\u000Apublic:\u000A  // disable copy constructor and operator=\u000A  DeviceToHostSideChannel()=delete;\u000A  DeviceToHostSideChannel(const DeviceToHostSideChannel &)=delete;\u000A  DeviceToHostSideChannel& operator=(DeviceToHostSideChannel const &)=delete;\u000A\u000A  static void Init(queue &q) {\u000A    q_ = &q;\u000A    MyConsumer::Init(q, 1);\u000A  };\u000A\u000A  static void Destroy(queue &q) {\u000A    q_ = nullptr;\u000A    MyConsumer::Destroy(q);\u000A  };\u000A\u000A  // blocking\u000A  static T read() {\u000A    // HOST CODE\u000A    // launch the kernel to read the data from the pipe into memory\u000A    // and wait for it to finish (blocking)\u000A    event dma, kernel;\u000A    std::tie(dma, kernel) = MyConsumer::Start(*q_);\u000A    dma.wait();\u000A    kernel.wait();\u000A\u000A    // the kernel has finished, so return the data\u000A    return MyConsumer::Data()[0];\u000A  }\u000A\u000A  // non-blocking\u000A  // call .wait() on the returned event to wait for the read to take place,\u000A  // then access the data using ::Data()[0]\u000A  static event read(bool &success_code) {\u000A    // start the kernel and return the event\u000A    // the user can use ::Data() later to get the data\u000A    // return the DMA event, since it happen second\u000A    success_code = true;\u000A    return MyConsumer::Start(*q_).first;\u000A  }\u000A\u000A  static void write(const T &data) {\u000A    // DEVICE CODE\u000A    MyConsumer::Pipe::write(data);\u000A  }\u000A\u000A  static void write(const T &data, bool &success_code) {\u000A    // DEVICE CODE\u000A    MyConsumer::Pipe::write(data, success_code);\u000A  }\u000A\u000A  static T Data() {\u000A    return MyConsumer::Data()[0];\u000A  }\u000A};\u000A\u000A#endif /* __HOSTSIDECHANNEL_HPP__ */\u000A"}, {"path":"/home/u93631/A10_oneapi/IOpipe/src/LoopbackTest.hpp", "name":"LoopbackTest.hpp", "has_active_debug_locs":false, "absName":"/home/u93631/A10_oneapi/IOpipe/src/LoopbackTest.hpp", "content":"#ifndef __LOOPBACKTEST_HPP__\u000A#define __LOOPBACKTEST_HPP__\u000A\u000A#include <CL/sycl.hpp>\u000A#include <sycl/ext/intel/fpga_extensions.hpp>\u000A\u000A#include \"FakeIOPipes.hpp\"\u000A\u000A// If the 'USE_REAL_IO_PIPE' macro is defined, this test will use real IO pipes.\u000A// To use this, ensure you have a BSP that supports IO pipes.\u000A// NOTE: define this BEFORE including the LoopbackTest.hpp and\u000A// SideChannelTest.hpp which will check for the presence of this macro.\u000A//#define USE_REAL_IO_PIPES\u000A\u000Ausing namespace sycl;\u000A\u000A// declare the kernel and pipe ID stucts globally to reduce name mangling\u000Astruct LoopBackMainKernel;\u000Astruct LoopBackReadIOPipeID { static constexpr unsigned id = 0; };\u000Astruct LoopBackWriteIOPipeID { static constexpr unsigned id = 1; };\u000A\u000A\u000A//\u000A// The simplest processing kernel. Streams data in 'IOPipeIn' and streams\u000A// it out 'IOPipeOut'. The developer of this kernel uses this abstraction\u000A// to create a streaming kernel. They don't particularly care whether the IO\u000A// pipes are 'real' or not, that is up to the system designer who works on\u000A// stitching together the whole system. In this tutorial, the stitching of the\u000A// full system is done below in the 'RunLoopbackSystem' function.\u000A//\u000Atemplate<class IOPipeIn, class IOPipeOut>\u000Aevent SubmitLoopbackKernel(queue& q, size_t count) {\u000A  return q.single_task<LoopBackMainKernel>([=] {\u000A    for (size_t i = 0; i < count; i++) {\u000A      auto data = IOPipeIn::read();\u000A      // !!! Your processing can go here !!!\u000A      IOPipeOut::write(data);\u000A    }\u000A  });\u000A}\u000A\u000A//\u000A// Run the loopback system\u000A//\u000Atemplate<typename T, bool use_usm_host_alloc>\u000Abool RunLoopbackSystem(queue& q, size_t count) {\u000A  bool passed = true;\u000A\u000A  //////////////////////////////////////////////////////////////////////////////\u000A  // IO pipes\u000A  constexpr size_t kIOPipeDepth = 4;\u000A#ifndef USE_REAL_IO_PIPES\u000A  // these are FAKE IO pipes (and their producer/consumer)\u000A  using FakeIOPipeInProducer = Producer<LoopBackReadIOPipeID,\u000A                                T, use_usm_host_alloc, kIOPipeDepth>;\u000A  using FakeIOPipeOutConsumer = Consumer<LoopBackWriteIOPipeID,\u000A                                 T, use_usm_host_alloc, kIOPipeDepth>;\u000A  using ReadIOPipe = typename FakeIOPipeInProducer::Pipe;\u000A  using WriteIOPipe = typename FakeIOPipeOutConsumer::Pipe;\u000A\u000A  // initialize the fake IO pipes\u000A  FakeIOPipeInProducer::Init(q, count);\u000A  FakeIOPipeOutConsumer::Init(q, count);\u000A#else\u000A  // these are REAL IO pipes\u000A  using ReadIOPipe = \u000A    ext::intel::kernel_readable_io_pipe<LoopBackReadIOPipeID,\u000A                                   T, kIOPipeDepth>;\u000A  using WriteIOPipe =\u000A    ext::intel::kernel_writeable_io_pipe<LoopBackWriteIOPipeID,\u000A                                    T, kIOPipeDepth>;\u000A#endif\u000A  //////////////////////////////////////////////////////////////////////////////\u000A\u000A  // FAKE IO PIPES ONLY\u000A#ifndef USE_REAL_IO_PIPES\u000A  // get the pointer to the fake input data\u000A  auto i_stream_data = FakeIOPipeInProducer::Data();\u000A\u000A  // create some random input data for the fake IO pipe\u000A  std::generate_n(i_stream_data, count, [&] { return rand() % 100; } );\u000A#endif\u000A\u000A  // submit the main processing kernel\u000A  auto kernel_event = SubmitLoopbackKernel<ReadIOPipe, WriteIOPipe>(q, count);\u000A\u000A  // FAKE IO PIPES ONLY\u000A#ifndef USE_REAL_IO_PIPES\u000A  // start the producer and consumer\u000A  event produce_dma_e, produce_kernel_e;\u000A  event consume_dma_e, consume_kernel_e;\u000A  std::tie(produce_dma_e, produce_kernel_e) = FakeIOPipeInProducer::Start(q);\u000A  std::tie(consume_dma_e, consume_kernel_e) = FakeIOPipeOutConsumer::Start(q);\u000A\u000A  // wait for producer and consumer to finish including the DMA events.\u000A  // NOTE: if USM host allocations are used, the dma events are noops.\u000A  produce_dma_e.wait();\u000A  produce_kernel_e.wait();\u000A  consume_dma_e.wait();\u000A  consume_kernel_e.wait();\u000A#endif\u000A\u000A  // Wait for main kernel to finish.\u000A  // NOTE: we can only wait on the loopback kernel because it knows how much\u000A  // data it expects to process ('count'). In general, this may not be the\u000A  // case and you may want the processing kernel to run 'forever' (or until the\u000A  // host tells it to stop). For an example of this, see 'SideChannelTest.hpp'.\u000A  kernel_event.wait();\u000A\u000A  // FAKE IO PIPES ONLY\u000A#ifndef USE_REAL_IO_PIPES\u000A  // get the pointer to the fake input data\u000A  auto o_stream_data = FakeIOPipeOutConsumer::Data();\u000A\u000A  // validate the output\u000A  for (size_t i = 0; i < count; i++) {\u000A    if (o_stream_data[i] != i_stream_data[i]) {\u000A      std::cerr << \"ERROR: output mismatch at entry \" << i << \": \"\u000A                << o_stream_data[i] << \" != \" << i_stream_data[i]\u000A                << \" (out != in)\\n\";\u000A      passed &= false;\u000A    }\u000A  }\u000A#endif\u000A\u000A  return passed;\u000A}\u000A\u000A\u000A#endif /* __LOOPBACKTEST_HPP__ */\u000A"}, {"path":"/home/u93631/A10_oneapi/IOpipe/src/SideChannelTest.hpp", "name":"SideChannelTest.hpp", "has_active_debug_locs":false, "absName":"/home/u93631/A10_oneapi/IOpipe/src/SideChannelTest.hpp", "content":"#ifndef __SIDECHANNELTEST_HPP__\u000A#define __SIDECHANNELTEST_HPP__\u000A\u000A#include <CL/sycl.hpp>\u000A#include <sycl/ext/intel/fpga_extensions.hpp>\u000A\u000A#include \"FakeIOPipes.hpp\"\u000A#include \"HostSideChannel.hpp\"\u000A\u000Ausing namespace sycl;\u000Ausing namespace std::chrono_literals;\u000A\u000A// declare the kernel and pipe ID stucts globally to reduce name mangling\u000Astruct SideChannelMainKernel;\u000Astruct SideChannelReadIOPipeID { static constexpr unsigned id = 0; };\u000Astruct SideChannelWriteIOPipeID { static constexpr unsigned id = 1; };\u000Astruct HostToDeviceSideChannelID;\u000Astruct DeviceToHostSideChannelID;\u000Astruct DeviceToHostDSideChannelID;\u000Astruct DeviceToHostTSideChannelID; \u000Astruct HostToDeviceTermSideChannelID;\u000Astruct HostToDeviceDTermSideChannelID;\u000A\u000A\u000A//\u000A// Submit the main processing kernel (or kernels, in general).\u000A// This function is templated on the IO pipes and the side channels.\u000A// It is agnostic to whether the the system is using real or fake IO pipes.\u000A//\u000A// This kernel streams data into and out of IO pipes (IOPipeIn and IOPipeOut,\u000A// respectively). If the value matches the current value of 'match_num', it\u000A// sends the value to the host via the HostToDeviceSideChannel. In the outer\u000A// loop, it reads configuration data from the host via the\u000A// HostToDeviceSideChannel and HostToDeviceTermSideChannel. The former updates\u000A// 'match_num' and the latter causes this kernel to break from the outer loop\u000A// and terminate.\u000A//\u000Atemplate<class IOPipeIn, class IOPipeOut,\u000A         class HostToDeviceSideChannel, class DeviceToHostSideChannel, class DeviceToHostDSideChannel,class DeviceToHostTSideChannel,\u000A         class HostToDeviceTermSideChannel,class HostToDeviceDTermSideChannel\u000A	 >\u000Aevent SubmitSideChannelKernels(queue& q, int initial_match_num,\u000A                               size_t frame_size) {\u000A  // the maximum number of consecutive input read misses before\u000A  // breaking out of the computation loop\u000A  // Why would you want to break out of the processing loop? One example\u000A  // is if you are expecting asynchronous updates from the host through a\u000A  // side channel.\u000A  constexpr size_t kTimeoutCounterMax = 1024;\u000A\u000A  // submit the main processing kernel\u000A  return q.single_task<SideChannelMainKernel>([=] {\u000A    int match_num = initial_match_num;\u000A    size_t timeout_counter;\u000A    size_t samples_processed = 0;\u000A    bool terminate = false;\u000A\u000A    while (!terminate) {\u000A      // check for an update to the sum_threshold from the host\u000A      bool valid_update;\u000A      int tmp = HostToDeviceSideChannel::read(valid_update);\u000A      if (valid_update) match_num = tmp;\u000A\u000A      // reset the timeout counter\u000A      timeout_counter = 0;\u000A\u000A      // if we processed a full frame, reset the counter\u000A      // this places a maximum on the number of elements we process before\u000A      // checking for an update from the host\u000A      if (samples_processed == frame_size) samples_processed = 0;\u000A\u000A      // do the main processing\u000A      while ((samples_processed != frame_size) && \u000A              (timeout_counter != kTimeoutCounterMax)) {\u000A        // read from the input IO pipe\u000A        bool valid_read;\u000A        auto val = IOPipeIn::read(valid_read);\u000A\u000A        if (valid_read) {\u000A          // reset the timeout counter since we read a valid piece of data\u000A          timeout_counter = 0;\u000A\u000A          // processed another sample in this frame\u000A          samples_processed++;\u000A          bool write_flag1 = true;\u000A          // check if the value matches\u000A          if (val == match_num) {\u000A            // value matches, so tell the host about it\u000A            DeviceToHostDSideChannel::write(val, write_flag1); \u000A            DeviceToHostSideChannel::write(val);\u000A            DeviceToHostTSideChannel::write(val,write_flag1);\u000A	  }\u000A\u000A	  bool write_flag2 = true;\u000A	  \u000A	  //if (val % 2 == 0){\u000A	  //   DeviceToHostTSideChannel::write(val,write_flag2);	  \u000A	 // }\u000A	  //else {\u000A	  //DeviceToHostDSideChannel::write(val);\u000A	  //}\u000A          \u000A          // propagate the input value to the output\u000A          IOPipeOut::write(val);\u000A        } else {\u000A          // increment the timeout counter since the read was invalid\u000A          timeout_counter++;\u000A        }\u000A      }\u000A\u000A      // the host uses this side channel to tell the kernel to exit\u000A      // Any successful read from this channel means the host wants this\u000A      // kernel to end; the actual value read doesn't matter\u000A      (void)HostToDeviceDTermSideChannel::read(terminate);\u000A      (void)HostToDeviceTermSideChannel::read(terminate);\u000A    }\u000A  });\u000A}\u000A\u000A//\u000A// This function builds the full system using fake IO pipes.\u000A// It creates, produces, and consumes the fake data and validates the output\u000A//\u000Atemplate<typename T, bool use_usm_host_alloc>\u000Abool RunSideChannelsSystem(queue& q, size_t count) {\u000A  //////////////////////////////////////////////////////////////////////////////\u000A  // IO pipes\u000A  // these are the FAKE IO pipes\u000A  using FakeIOPipeInProducer = Producer<SideChannelReadIOPipeID,\u000A                                T, use_usm_host_alloc>;\u000A  using FakeIOPipeOutConsumer = Consumer<SideChannelWriteIOPipeID,\u000A                                 T, use_usm_host_alloc>;\u000A  using ReadIOPipe = typename FakeIOPipeInProducer::Pipe;\u000A  using WriteIOPipe = typename FakeIOPipeOutConsumer::Pipe;\u000A\u000A  // initialize the fake IO pipes\u000A  FakeIOPipeInProducer::Init(q, count);\u000A  FakeIOPipeOutConsumer::Init(q, count);\u000A  //////////////////////////////////////////////////////////////////////////////\u000A\u000A  //////////////////////////////////////////////////////////////////////////////\u000A  // the side channels\u000A  using MyHostToDeviceSideChannel = \u000A    HostToDeviceSideChannel<HostToDeviceSideChannelID,\u000A                            int, use_usm_host_alloc, 1>;\u000A  using MyHostToDeviceTermSideChannel = \u000A    HostToDeviceSideChannel<HostToDeviceTermSideChannelID,\u000A                            char, use_usm_host_alloc, 1>;\u000A    using MyHostToDeviceDTermSideChannel =\u000A    HostToDeviceSideChannel<HostToDeviceDTermSideChannelID,\u000A                            char, use_usm_host_alloc, 1>;\u000A  \u000A  // This side channel is used to sent updates from the device to the host.\u000A  // We explicitly set the depth of the FIFO to '8' here. If the host does not\u000A  // read from this side channel quick enough it will causes the main processing\u000A  // kernel to stall. Therefore, sizing the FIFO is something to consider when\u000A  // designing a 'real' system that uses side channels. In this tutorial, the\u000A  // frequency of updates from the device is so low that this channel can be\u000A  // shallow.\u000A  using MyDeviceToHostSideChannel = \u000A    DeviceToHostSideChannel<DeviceToHostSideChannelID,\u000A                            int, use_usm_host_alloc, 8>;\u000A  using MyDeviceToHostDSideChannel =\u000A    DeviceToHostSideChannel<DeviceToHostDSideChannelID,\u000A                            int, use_usm_host_alloc, 8>;\u000A  using MyDeviceToHostTSideChannel =\u000A    DeviceToHostSideChannel<DeviceToHostTSideChannelID,\u000A                            int, use_usm_host_alloc, 8>;\u000A\u000A  // initialize the side channels\u000A  MyHostToDeviceSideChannel::Init(q);\u000A  MyHostToDeviceTermSideChannel::Init(q);\u000A  MyHostToDeviceDTermSideChannel::Init(q); \u000A  //MyHostToDeviceTTermSideChannel::Init(q);\u000A  MyDeviceToHostSideChannel::Init(q);\u000A  MyDeviceToHostDSideChannel::Init(q); \u000A  MyDeviceToHostTSideChannel::Init(q);\u000A  //////////////////////////////////////////////////////////////////////////////\u000A\u000A  // get the pointer to the fake input data\u000A  auto i_stream_data = FakeIOPipeInProducer::Data();\u000A\u000A  // Create some random input data\u000A  // The range of the random number is [0, count/4), which means the probability\u000A  // of a number ('match_num') matching any number in the list is 1/(count/4)=\u000A  // 4/count. Therefore, the average number of matches in the input stream\u000A  // is count * (4/count) = 4.\u000A  int rand_max = std::max(4, (int)(count / 4));\u000A  size_t frame_size = 1024;\u000A  std::generate_n(i_stream_data, count, [&] { return rand() % rand_max; } );\u000A\u000A  // submit the main kernels, once and only once\u000A  auto main_kernel = \u000A    SubmitSideChannelKernels<ReadIOPipe, WriteIOPipe, MyHostToDeviceSideChannel,\u000A                             MyDeviceToHostSideChannel,MyDeviceToHostDSideChannel,MyDeviceToHostTSideChannel,\u000A                             MyHostToDeviceTermSideChannel,MyHostToDeviceDTermSideChannel\u000A				     >(q, -1, frame_size);\u000A\u000A  //////////////////////////////////////////////////////////////////////////////\u000A  // this lambda will perform a single test to detect all `match_num` elements\u000A  auto test_lambda = [&](int match_num) {\u000A    // determine expected number of updates for this 'match_num'\u000A    size_t expected_updated_count = \u000A      std::count(i_stream_data, i_stream_data + count, match_num);\u000A    std::vector<int> device_updates;\u000A    device_updates.reserve(expected_updated_count);\u000A\u000A    std::cout << \"Checking for values matching '\" << match_num << \"', \"\u000A              << \"expecting \" << expected_updated_count << \" matches\\n\";\u000A\u000A    // first, update the kernel with the number to match (blocking)\u000A    MyHostToDeviceSideChannel::write(match_num);\u000A\u000A    // This sleep is an artifact of validating the side channel updates.\u000A    // The line of code above writes the new 'match_num' data into\u000A    // a pipe to be read by the main processing kernel on the device. However,\u000A    // just because the value was written to the pipe doesn't mean that the main\u000A    // processing kernel has seen it. For a 'real' streaming design, we\u000A    // typically wouldn't care about this race condition since the host->device\u000A    // updates are asyncrhonous. However, for the sake of this tutorial, we want\u000A    // to be able to validate that the host->device side channel update took\u000A    // place. Therefore, we add a sleep here; 10ms should be plenty of time\u000A    // for the main processing kernel to read the value from the FIFO where we\u000A    // know it resides (since the previous operation is blocking).\u000A    std::this_thread::sleep_for(10ms);\u000A    std::cout <<\"starting...\\n\";\u000A    // launch the producer and consumer to send the data through the kernel\u000A    event producer_dma_event, producer_kernel_event;\u000A    event consumer_dma_event, consumer_kernel_event;\u000A    std::tie(producer_dma_event, producer_kernel_event) =\u000A      FakeIOPipeInProducer::Start(q);\u000A    std::tie(consumer_dma_event, consumer_kernel_event) =\u000A      FakeIOPipeOutConsumer::Start(q);\u000A    \u000A    // get updates from the device\u000A    bool flag=true;\u000A    for (size_t i = 0; i < expected_updated_count; i++) {   \u000A      auto device_update = MyDeviceToHostSideChannel::read();\u000A      auto feedback = MyDeviceToHostDSideChannel::read(flag);\u000A      feedback = MyDeviceToHostTSideChannel::read(flag);\u000A      std::cout<<\"hello\\n\";\u000A      device_updates.push_back(device_update);\u000A    } \u000A   \u000A    std::cout<<flag<<\"\\n\";\u000A    //  wait for producer and consumer to finish, including the DMA events\u000A    // NOTE: if USM host allocations are used, the dma events are noops.\u000A    producer_dma_event.wait();\u000A    producer_kernel_event.wait();\u000A    consumer_dma_event.wait();\u000A    consumer_kernel_event.wait();\u000A\u000A    bool test_passed = true;\u000A\u000A    // get the pointer to the fake output data\u000A    auto o_stream_data = FakeIOPipeOutConsumer::Data();\u000A\u000A    // validate the output\u000A    for (size_t i = 0; i < count; i++) {\u000A      if (o_stream_data[i] != i_stream_data[i]) {\u000A        std::cerr << \"ERROR: output mismatch at entry \" << i << \": \"\u000A                  << o_stream_data[i] << \" != \" << i_stream_data[i]\u000A                  << \" (out != in)\\n\";\u000A        test_passed &= false;\u000A      }\u000A    }\u000A\u000A    // validate the updates from the device\u000A    for (size_t i = 0; i < expected_updated_count; i++) {\u000A      if (device_updates[i] != match_num) {\u000A        std::cerr << \"ERROR: unexpected update value from device: \"\u000A                  << device_updates[i] << \" != \" << match_num\u000A                  << \" (update != expected)\\n\";\u000A        test_passed &= false;\u000A      }\u000A    }\u000A\u000A    return test_passed;\u000A  };\u000A  //////////////////////////////////////////////////////////////////////////////\u000A\u000A  // run a couple tests with random 'match_num'\u000A  // NOTE: the main processing kernel does NOT exit between these calls\u000A  bool passed = true;\u000A  passed &= test_lambda(rand() % rand_max);\u000A  passed &= test_lambda(rand() % rand_max);\u000A  passed &= test_lambda(rand() % rand_max);\u000A\u000A  // we are done testing now, so send a signal to main processing kernel to exit\u000A  MyHostToDeviceTermSideChannel::write(0);\u000A  MyHostToDeviceDTermSideChannel::write(0);\u000A\u000A  // wait for the main kernel to finish\u000A  main_kernel.wait();\u000A\u000A  // destroy the fake IO pipes and the side channels\u000A  FakeIOPipeInProducer::Destroy(q);\u000A  FakeIOPipeOutConsumer::Destroy(q);\u000A  MyHostToDeviceSideChannel::Destroy(q);\u000A  MyHostToDeviceTermSideChannel::Destroy(q);\u000A  MyHostToDeviceDTermSideChannel::Destroy(q);\u000A  MyDeviceToHostSideChannel::Destroy(q);\u000A  MyDeviceToHostDSideChannel::Destroy(q);\u000A  MyDeviceToHostTSideChannel::Destroy(q);\u000A  return passed;\u000A}\u000A\u000A#endif /* __SIDECHANNELTEST_HPP__ */\u000A"}, {"path":"/glob/development-tools/versions/oneapi/2022.1.2/oneapi/dev-utilities/2021.5.2/include/dpc_common.hpp", "name":"dpc_common.hpp", "has_active_debug_locs":false, "absName":"/glob/development-tools/versions/oneapi/2022.1.2/oneapi/dev-utilities/2021.5.2/include/dpc_common.hpp", "content":"// Copyright (C) 2020 Intel Corporation\u000A// SPDX-License-Identifier: MIT\u000A\u000A#ifndef _DP_HPP\u000A#define _DP_HPP\u000A\u000A#include <stdlib.h>\u000A#include <exception>\u000A\u000A#include <CL/sycl.hpp>\u000A\u000Anamespace dpc_common {\u000A// This exception handler will catch async exceptions\u000Astatic auto exception_handler = [](cl::sycl::exception_list eList) {\u000A  for (std::exception_ptr const &e : eList) {\u000A    try {\u000A      std::rethrow_exception(e);\u000A    } catch (std::exception const &e) {\u000A#if _DEBUG\u000A      std::cout << \"Failure\" << std::endl;\u000A#endif\u000A      std::terminate();\u000A    }\u000A  }\u000A};\u000A\u000A// The TimeInterval is a simple RAII class.\u000A// Construct the timer at the point you want to start timing.\u000A// Use the Elapsed() method to return time since construction.\u000A\u000Aclass TimeInterval {\u000A public:\u000A  TimeInterval() : start_(std::chrono::steady_clock::now()) {}\u000A\u000A  double Elapsed() {\u000A    auto now = std::chrono::steady_clock::now();\u000A    return std::chrono::duration_cast<Duration>(now - start_).count();\u000A  }\u000A\u000A private:\u000A  using Duration = std::chrono::duration<double>;\u000A  std::chrono::steady_clock::time_point start_;\u000A};\u000A\u000A};  // namespace dpc_common\u000A\u000A#endif\u000A"}, {"path":"/home/u93631/A10_oneapi/IOpipe/src/io_streaming.cpp", "name":"io_streaming.cpp", "has_active_debug_locs":false, "absName":"/home/u93631/A10_oneapi/IOpipe/src/io_streaming.cpp", "content":"#include <algorithm>\u000A#include <chrono>\u000A#include <iostream>\u000A#include <numeric>\u000A#include <chrono>\u000A#include <thread>\u000A\u000A#include <CL/sycl.hpp>\u000A#include <sycl/ext/intel/fpga_extensions.hpp>\u000A\u000A// dpc_common.hpp can be found in the dev-utilities include folder.\u000A// e.g., $ONEAPI_ROOT/dev-utilities/include/dpc_common.hpp\u000A#include \"dpc_common.hpp\"\u000A\u000A// The type that will stream through the IO pipe. When using real IO pipes,\u000A// make sure the width of this datatype matches the width of the IO pipe, which\u000A// you can find in the BSP XML file.\u000Ausing IOPipeType = int;\u000A\u000A#include \"LoopbackTest.hpp\"\u000A#include \"SideChannelTest.hpp\"\u000A\u000Ausing namespace sycl;\u000A\u000A// check is USM host allocations are enabled\u000A#if defined(USM_HOST_ALLOCATIONS)\u000Aconstexpr bool kUseUSMHostAllocation = true;\u000A#else\u000Aconstexpr bool kUseUSMHostAllocation = false;\u000A#endif\u000A\u000Aint main() {\u000A  bool passed = true;\u000A\u000A#if defined(FPGA_EMULATOR)\u000A  size_t count = 1 << 12;\u000A#else\u000A  size_t count = 1 << 24;\u000A#endif\u000A\u000A  try {\u000A    // device selector\u000A#if defined(FPGA_EMULATOR)\u000A    ext::intel::fpga_emulator_selector selector;\u000A#else\u000A    ext::intel::fpga_selector selector;\u000A#endif\u000A\u000A    // queue properties to enable SYCL profiling of kernels\u000A    auto prop_list = property_list{property::queue::enable_profiling()};\u000A\u000A    // create the device queue\u000A    queue q(selector, dpc_common::exception_handler, prop_list);\u000A\u000A    // run the loopback example system\u000A    // see 'LoopbackTest.hpp'\u000A    std::cout << \"Running loopback test\\n\";\u000A    passed &= \u000A      RunLoopbackSystem<IOPipeType, kUseUSMHostAllocation>(q, count);\u000A\u000A    // run the side channel example system\u000A    // see 'SideChannelTest.hpp'\u000A    std::cout << \"Running side channel test\\n\";\u000A    passed &= \u000A      RunSideChannelsSystem<IOPipeType, kUseUSMHostAllocation>(q, count);\u000A\u000A  } catch (exception const &e) {\u000A    // Catches exceptions in the host code\u000A    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\u000A    // Most likely the runtime couldn't find FPGA hardware!\u000A    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\u000A      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\u000A                   \"system has a correctly configured FPGA board.\\n\";\u000A      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\u000A      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\u000A                   \"-DFPGA_EMULATOR.\\n\";\u000A    }\u000A    std::terminate();\u000A  }\u000A\u000A  if (passed) {\u000A    std::cout << \"PASSED\\n\";\u000A    return 0;\u000A  } else {\u000A    std::cout << \"FAILED\\n\";\u000A    return 1;\u000A  }\u000A}\u000A\u000A"}]