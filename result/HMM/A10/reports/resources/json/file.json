[{"path":"/home/u93631/A10_oneapi/HMM/src/FakeIOPipes.hpp", "name":"FakeIOPipes.hpp", "has_active_debug_locs":false, "absName":"/home/u93631/A10_oneapi/HMM/src/FakeIOPipes.hpp", "content":"#ifndef __FAKEIOPIPES_HPP__\u000A#define __FAKEIOPIPES_HPP__\u000A\u000A#include <iostream>\u000A#include <type_traits>\u000A#include <utility>\u000A\u000A#include <CL/sycl.hpp>\u000A#include <sycl/ext/intel/fpga_extensions.hpp>\u000A\u000A// the \"detail\" namespace is commonly used in C++ as an internal namespace\u000A// (to a file) that is not meant to be visible to the public and should be\u000A// ignored by external users. That is to say, you should never have the line:\u000A// \"using namespace detail;\" in your code!\u000A//\u000A// \"internal\" is another common name for a namespace like this.\u000Anamespace detail {\u000A\u000Ausing namespace sycl;\u000A\u000Atemplate <typename ID, typename T, bool use_host_alloc>\u000Aclass ProducerConsumerBaseImpl {\u000A protected:\u000A  // private members\u000A  static inline T *host_data_{nullptr};\u000A  static inline T *device_data_{nullptr};\u000A  static inline size_t count_{};\u000A  static inline bool initialized_{false};\u000A\u000A  // use some fancy C++ metaprogramming to get the correct pointer type\u000A  // based on the template variable\u000A  typedef\u000A      typename std::conditional_t<use_host_alloc, host_ptr<T>, device_ptr<T>>\u000A          kernel_ptr_type;\u000A\u000A  // private constructor so users cannot make an object\u000A  ProducerConsumerBaseImpl(){};\u000A\u000A  static T *get_kernel_ptr() {\u000A    return use_host_alloc ? host_data_ : device_data_;\u000A  }\u000A\u000A  static void initialized_check() {\u000A    if (!initialized_) {\u000A      std::cerr << \"ERROR: Init() has not been called\\n\";\u000A      std::terminate();\u000A    }\u000A  }\u000A\u000A public:\u000A  // disable copy constructor and operator=\u000A  ProducerConsumerBaseImpl(const ProducerConsumerBaseImpl &) = delete;\u000A  ProducerConsumerBaseImpl &operator=(ProducerConsumerBaseImpl const &) =\u000A      delete;\u000A\u000A  static void Init(queue &q, size_t count) {\u000A    // make sure init hasn't already been called\u000A    if (initialized_) {\u000A      std::cerr << \"ERROR: Init() was already called\\n\";\u000A      std::terminate();\u000A    }\u000A\u000A    // track count\u000A    count_ = count;\u000A\u000A    // check for USM support\u000A    device d = q.get_device();\u000A    if (!d.get_info<info::device::usm_host_allocations>() && use_host_alloc) {\u000A      std::cerr << \"ERROR: The selected device does not support USM host\"\u000A                << \" allocations\\n\";\u000A      std::terminate();\u000A    }\u000A    if (!d.get_info<info::device::usm_device_allocations>()) {\u000A      std::cerr << \"ERROR: The selected device does not support USM device\"\u000A                << \" allocations\\n\";\u000A      std::terminate();\u000A    }\u000A\u000A    // Allocate the space the user requested. Calling a different malloc\u000A    // based on whether the user wants to use USM host allocations or not.\u000A    if (use_host_alloc) {\u000A      host_data_ = malloc_host<T>(count_, q);\u000A    } else {\u000A      host_data_ = new T[count_];\u000A    }\u000A\u000A    if (host_data_ == nullptr) {\u000A      std::cerr << \"ERROR: failed to allocate space for host_data_\\n\";\u000A      std::terminate();\u000A    }\u000A\u000A    // if not using host allocations, allocate device memory\u000A    if (!use_host_alloc) {\u000A      device_data_ = malloc_device<T>(count_, q);\u000A      if (device_data_ == nullptr) {\u000A        std::cerr << \"ERROR: failed to allocate space for\"\u000A                  << \"device_data_\\n\";\u000A        std::terminate();\u000A      }\u000A    }\u000A\u000A    initialized_ = true;\u000A  }\u000A\u000A  static void Destroy(queue &q) {\u000A    initialized_check();\u000A\u000A    // free memory depending on 'use_host_alloc' flag\u000A    if (use_host_alloc) {\u000A      // free USM host allocation\u000A      sycl::free(host_data_, q);\u000A    } else {\u000A      // free C++ allocated memory\u000A      delete[] host_data_;\u000A\u000A      // free USM device allocation\u000A      sycl::free(device_data_, q);\u000A    }\u000A\u000A    initialized_ = false;\u000A  }\u000A\u000A  static size_t Count() {\u000A    initialized_check();\u000A    return count_;\u000A  }\u000A\u000A  static T *Data() {\u000A    initialized_check();\u000A    return host_data_;\u000A  }\u000A};\u000A\u000A////////////////////////////////////////////////////////////////////////////////\u000A// Producer implementation\u000Atemplate <typename Id, typename T, bool use_host_alloc, size_t min_capacity>\u000Aclass ProducerImpl : public ProducerConsumerBaseImpl<Id, T, use_host_alloc> {\u000A private:\u000A  // base implementation alias\u000A  using BaseImpl = ProducerConsumerBaseImpl<Id, T, use_host_alloc>;\u000A  using kernel_ptr_type = typename BaseImpl::kernel_ptr_type;\u000A\u000A  // IDs for the pipe and kernel\u000A  class PipeID;\u000A  class KernelID;\u000A\u000A  // private constructor so users cannot make an object\u000A  ProducerImpl(){};\u000A\u000A public:\u000A  // disable copy constructor and operator=\u000A  ProducerImpl(const ProducerImpl &) = delete;\u000A  ProducerImpl &operator=(ProducerImpl const &) = delete;\u000A\u000A  // the pipe to connect to in device code\u000A  using Pipe = sycl::ext::intel::pipe<PipeID, T, min_capacity>;\u000A\u000A  // the implementation of the static\u000A  static std::pair<event, event> Start(queue &q,\u000A                                       size_t count = BaseImpl::count_) {\u000A    // make sure initialized has been called\u000A    BaseImpl::initialized_check();\u000A\u000A    // can't produce more data than exists\u000A    if (count > BaseImpl::count_) {\u000A      std::cerr << \"ERROR: Start() called with count=\" << count\u000A                << \" but allocated size is \" << BaseImpl::count_ << \"\\n\";\u000A      std::terminate();\u000A    }\u000A\u000A    // If we aren't using USM host allocations, must transfer memory to device\u000A    event dma_event;\u000A    if (!use_host_alloc) {\u000A      dma_event = q.memcpy(BaseImpl::device_data_, BaseImpl::host_data_,\u000A                           BaseImpl::count_ * sizeof(T));\u000A    }\u000A\u000A    // pick the right pointer to pass to the kernel\u000A    auto kernel_ptr = BaseImpl::get_kernel_ptr();\u000A\u000A    // launch the kernel (use event.depends_on to wait on the memcpy)\u000A    auto kernel_event = q.submit([&](handler &h) {\u000A      // the kernel must wait until the DMA transfer is done before launching\u000A      // this will only take affect it we actually performed the DMA above\u000A      h.depends_on(dma_event);\u000A\u000A      // the producing kernel\u000A      // NO-FORMAT comments are for clang-format\u000A      h.single_task<Id>([=\u000A      ]() [[intel::kernel_args_restrict]] {  // NO-FORMAT: Attribute\u000A        kernel_ptr_type ptr(kernel_ptr);\u000A        for (size_t i = 0; i < count; i++) {\u000A          auto d = *(ptr + i);\u000A          Pipe::write(d);\u000A        }\u000A      });\u000A    });\u000A\u000A    return std::make_pair(dma_event, kernel_event);\u000A  }\u000A};\u000A////////////////////////////////////////////////////////////////////////////////\u000A\u000A////////////////////////////////////////////////////////////////////////////////\u000A// Consumer implementation\u000Atemplate <typename Id, typename T, bool use_host_alloc, size_t min_capacity>\u000Aclass ConsumerImpl : public ProducerConsumerBaseImpl<Id, T, use_host_alloc> {\u000A private:\u000A  // base implementation alias\u000A  using BaseImpl = ProducerConsumerBaseImpl<Id, T, use_host_alloc>;\u000A  using kernel_ptr_type = typename BaseImpl::kernel_ptr_type;\u000A\u000A  // IDs for the pipe and kernel\u000A  class PipeID;\u000A  class KernelID;\u000A\u000A  // private constructor so users cannot make an object\u000A  ConsumerImpl(){};\u000A\u000A public:\u000A  // disable copy constructor and operator=\u000A  ConsumerImpl(const ConsumerImpl &) = delete;\u000A  ConsumerImpl &operator=(ConsumerImpl const &) = delete;\u000A\u000A  // the pipe to connect to in device code\u000A  using Pipe = sycl::ext::intel::pipe<PipeID, T, min_capacity>;\u000A\u000A  static std::pair<event, event> Start(queue &q,\u000A                                       size_t count = BaseImpl::count_) {\u000A    // make sure initialized has been called\u000A    BaseImpl::initialized_check();\u000A\u000A    // can't produce more data than exists\u000A    if (count > BaseImpl::count_) {\u000A      std::cerr << \"ERROR: Start() called with count=\" << count\u000A                << \" but allocated size is \" << BaseImpl::count_ << \"\\n\";\u000A      std::terminate();\u000A    }\u000A\u000A    // pick the right pointer to pass to the kernel\u000A    auto kernel_ptr = BaseImpl::get_kernel_ptr();\u000A\u000A    // launch the kernel to read the output into device side global memory\u000A    auto kernel_event = q.submit([&](handler &h) {\u000A      // NO-FORMAT comments are for clang-format\u000A      h.single_task<Id>([=\u000A      ]() [[intel::kernel_args_restrict]] {  // NO-FORMAT: Attribute\u000A        kernel_ptr_type ptr(kernel_ptr);\u000A        for (size_t i = 0; i < count; i++) {\u000A          auto d = Pipe::read();\u000A          *(ptr + i) = d;\u000A        }\u000A      });\u000A    });\u000A\u000A    // if the user wanted to use board memory, copy the data back to the host\u000A    event dma_event;\u000A    if (!use_host_alloc) {\u000A      // launch a task to copy the data back from the device. Use the\u000A      // event.depends_on signal to wait for the kernel to finish first.\u000A      dma_event = q.submit([&](handler &h) {\u000A        h.depends_on(kernel_event);\u000A        h.memcpy(BaseImpl::host_data_, BaseImpl::device_data_,\u000A                 BaseImpl::count_ * sizeof(T));\u000A      });\u000A    }\u000A\u000A    return std::make_pair(dma_event, kernel_event);\u000A  }\u000A};\u000A////////////////////////////////////////////////////////////////////////////////\u000A\u000A}  // namespace detail\u000A\u000A// alias the implementations to face the user\u000Atemplate <typename Id, typename T, bool use_host_alloc, size_t min_capacity = 0>\u000Ausing Producer = detail::ProducerImpl<Id, T, use_host_alloc, min_capacity>;\u000A\u000Atemplate <typename Id, typename T, bool use_host_alloc, size_t min_capacity = 0>\u000Ausing Consumer = detail::ConsumerImpl<Id, T, use_host_alloc, min_capacity>;\u000A\u000A// convenient aliases to get a host or device allocation producer/consumer\u000Atemplate <typename Id, typename T, size_t min_capacity = 0>\u000Ausing HostConsumer = Consumer<Id, T, true, min_capacity>;\u000A\u000Atemplate <typename Id, typename T, size_t min_capacity = 0>\u000Ausing DeviceConsumer = Consumer<Id, T, false, min_capacity>;\u000A\u000Atemplate <typename Id, typename T, size_t min_capacity = 0>\u000Ausing HostProducer = Producer<Id, T, true, min_capacity>;\u000A\u000Atemplate <typename Id, typename T, size_t min_capacity = 0>\u000Ausing DeviceProducer = Producer<Id, T, false, min_capacity>;\u000A\u000A#endif /* __FAKEIOPIPES_HPP__ */\u000A"}, {"path":"/home/u93631/A10_oneapi/HMM/src/HostSideChannel.hpp", "name":"HostSideChannel.hpp", "has_active_debug_locs":false, "absName":"/home/u93631/A10_oneapi/HMM/src/HostSideChannel.hpp", "content":"#ifndef __HOSTSIDECHANNEL_HPP__\u000A#define __HOSTSIDECHANNEL_HPP__\u000A\u000A#include <iostream>\u000A#include <type_traits>\u000A\u000A#include <CL/sycl.hpp>\u000A#include <sycl/ext/intel/fpga_extensions.hpp>\u000A\u000A#include \"FakeIOPipes.hpp\"\u000A\u000Ausing namespace sycl;\u000A\u000A//\u000A// This class provides a convenient, but low-bandwidth and relatively high\u000A// latency, side channel to send data from the host to the device. It exposes\u000A// a read() interface to the DEVICE code that the user can treat just like a\u000A// SYCL pipe. It also exposes a write interface to the HOST that allows the\u000A// user to easily write data from host to the device\u000A//\u000Atemplate <typename Id, typename T, bool use_host_alloc, size_t min_capacity=0>\u000Aclass HostToDeviceSideChannel {\u000Aprotected:\u000A  using MyProducer = Producer<Id, T, use_host_alloc, min_capacity>;\u000A  static inline queue* q_{nullptr};\u000A\u000Apublic:\u000A  // disable copy constructor and operator=\u000A  HostToDeviceSideChannel()=delete;\u000A  HostToDeviceSideChannel(const HostToDeviceSideChannel &)=delete;\u000A  HostToDeviceSideChannel& operator=(HostToDeviceSideChannel const &)=delete;\u000A\u000A  static void Init(queue &q) {\u000A    q_ = &q;\u000A    MyProducer::Init(q, 1);\u000A  };\u000A\u000A  static void Destroy(queue &q) {\u000A    q_ = nullptr;\u000A    MyProducer::Destroy(q);\u000A  };\u000A\u000A  static T read() {\u000A    // DEVICE CODE\u000A    return MyProducer::Pipe::read();\u000A  }\u000A\u000A  static T read(bool &success_code) {\u000A    // DEVICE CODE\u000A    return MyProducer::Pipe::read(success_code);\u000A  }\u000A\u000A  // blocking\u000A  static void write(const T &data) {\u000A    // HOST CODE\u000A    // populate the data\u000A    MyProducer::Data()[0] = data;\u000A\u000A    // start the kernel and wait on it to finish (blocking)\u000A    event dma, kernel;\u000A    std::tie(dma, kernel) = MyProducer::Start(*q_);\u000A    dma.wait();\u000A    kernel.wait();\u000A  }\u000A\u000A  // non-blocking\u000A  // Call .wait() on the returned event to wait for the write to take place\u000A  static event write(const T &data, bool &success_code) {\u000A    // HOST CODE\u000A    // always succeed\u000A    success_code = true;\u000A\u000A    // populate the data\u000A    MyProducer::Data()[0] = data;\u000A\u000A    // start the kernel and return the kernel event\u000A    return MyProducer::Start(*q_).second;\u000A  }\u000A};\u000A\u000A//\u000A// This class provides a convenient, but not highly performing, side channel\u000A// to send data from the device to the host. It exposes a read() interface\u000A// to the HOST code that lets the user get updates from the device.\u000A// It also exposes a write interface to the DEVICE that allows the user to\u000A// easily write data from device to the host.\u000A//\u000Atemplate <typename Id, typename T, bool use_host_alloc, size_t min_capacity=0>\u000Aclass DeviceToHostSideChannel {\u000Aprotected:\u000A  using MyConsumer = Consumer<Id, T, use_host_alloc, min_capacity>;\u000A  static inline queue* q_{nullptr};\u000A\u000Apublic:\u000A  // disable copy constructor and operator=\u000A  DeviceToHostSideChannel()=delete;\u000A  DeviceToHostSideChannel(const DeviceToHostSideChannel &)=delete;\u000A  DeviceToHostSideChannel& operator=(DeviceToHostSideChannel const &)=delete;\u000A\u000A  static void Init(queue &q) {\u000A    q_ = &q;\u000A    MyConsumer::Init(q, 1);\u000A  };\u000A\u000A  static void Destroy(queue &q) {\u000A    q_ = nullptr;\u000A    MyConsumer::Destroy(q);\u000A  };\u000A\u000A  // blocking\u000A  static T read() {\u000A    // HOST CODE\u000A    // launch the kernel to read the data from the pipe into memory\u000A    // and wait for it to finish (blocking)\u000A    event dma, kernel;\u000A    std::tie(dma, kernel) = MyConsumer::Start(*q_);\u000A    dma.wait();\u000A    kernel.wait();\u000A\u000A    // the kernel has finished, so return the data\u000A    return MyConsumer::Data()[0];\u000A  }\u000A\u000A  // non-blocking\u000A  // call .wait() on the returned event to wait for the read to take place,\u000A  // then access the data using ::Data()[0]\u000A  static event read(bool &success_code) {\u000A    // start the kernel and return the event\u000A    // the user can use ::Data() later to get the data\u000A    // return the DMA event, since it happen second\u000A    success_code = true;\u000A    return MyConsumer::Start(*q_).first;\u000A  }\u000A\u000A  static void write(const T &data) {\u000A    // DEVICE CODE\u000A    MyConsumer::Pipe::write(data);\u000A  }\u000A\u000A  static void write(const T &data, bool &success_code) {\u000A    // DEVICE CODE\u000A    MyConsumer::Pipe::write(data, success_code);\u000A  }\u000A\u000A  static T Data() {\u000A    return MyConsumer::Data()[0];\u000A  }\u000A};\u000A\u000A#endif /* __HOSTSIDECHANNEL_HPP__ */\u000A"}, {"path":"/glob/development-tools/versions/oneapi/2022.3/oneapi/dev-utilities/2021.7.0/include/dpc_common.hpp", "name":"dpc_common.hpp", "has_active_debug_locs":false, "absName":"/glob/development-tools/versions/oneapi/2022.3/oneapi/dev-utilities/2021.7.0/include/dpc_common.hpp", "content":"// Copyright (C) 2020 Intel Corporation\u000A// SPDX-License-Identifier: MIT\u000A\u000A#ifndef _DP_HPP\u000A#define _DP_HPP\u000A\u000A#include <stdlib.h>\u000A#include <exception>\u000A\u000A#include <CL/sycl.hpp>\u000A\u000Anamespace dpc_common {\u000A// This exception handler will catch async exceptions\u000Astatic auto exception_handler = [](cl::sycl::exception_list eList) {\u000A  for (std::exception_ptr const &e : eList) {\u000A    try {\u000A      std::rethrow_exception(e);\u000A    } catch (std::exception const &e) {\u000A#if _DEBUG\u000A      std::cout << \"Failure\" << std::endl;\u000A#endif\u000A      std::terminate();\u000A    }\u000A  }\u000A};\u000A\u000A// The TimeInterval is a simple RAII class.\u000A// Construct the timer at the point you want to start timing.\u000A// Use the Elapsed() method to return time since construction.\u000A\u000Aclass TimeInterval {\u000A public:\u000A  TimeInterval() : start_(std::chrono::steady_clock::now()) {}\u000A\u000A  double Elapsed() {\u000A    auto now = std::chrono::steady_clock::now();\u000A    return std::chrono::duration_cast<Duration>(now - start_).count();\u000A  }\u000A\u000A private:\u000A  using Duration = std::chrono::duration<double>;\u000A  std::chrono::steady_clock::time_point start_;\u000A};\u000A\u000A};  // namespace dpc_common\u000A\u000A#endif\u000A"}, {"path":"/home/u93631/A10_oneapi/HMM/src/hidden-markov-models_heterofuzz_value_range_no_prob.cpp", "name":"hidden-markov-models_heterofuzz_value_range_no_prob.cpp", "has_active_debug_locs":false, "absName":"/home/u93631/A10_oneapi/HMM/src/hidden-markov-models_heterofuzz_value_range_no_prob.cpp", "content":"//==============================================================\u000A// Copyright © Intel Corporation\u000A//\u000A// SPDX-License-Identifier: MIT\u000A// =============================================================\u000A//\u000A// Hidden Markov Models: this code sample implements the Viterbi algorithm which is a dynamic \u000A// programming algorithm for finding the most likely sequence of hidden states—\u000A// called the Viterbi path—that results in a sequence of observed events,\u000A// especially in the context of Markov information sources and HMM.\u000A//\u000A// The sample can use GPU offload to compute sequential steps of multiple graph traversals simultaneously.\u000A//\u000A// - Initially, the dataset for algorithm processing is generated : initial states probability \u000A// distribution Pi, transition matrix A, emission matrix B and the sequence or the observations \u000A// produced by hidden Markov process.\u000A// - First, the matrix of Viterbi values on the first states are initialized using distribution Pi \u000A// and emission matrix B. The matrix of back pointers is initialized with default values -1.\u000A// - Then, for each time step the Viterbi matrix is set to the maximal possible value using A, B and Pi.\u000A// - Finally, the state with maximum Viterbi value on the last step is set as a final state of \u000A// the Viterbi path and the previous nodes of this path are detemined using the correspondent rows \u000A// of back pointers matrix for each of the steps except the last one.\u000A//\u000A// Note: The implementation uses logarithms of the probabilities to process small numbers correctly\u000A// and to replace multiplication operations with addition operations.\u000A\u000A#include <CL/sycl.hpp>\u000A#include <iostream>\u000A#include <limits>\u000A#include <math.h>\u000A#include <iostream>\u000A#include <cstdio>\u000A#include \"FakeIOPipes.hpp\"\u000A#include \"HostSideChannel.hpp\"\u000A// dpc_common.hpp can be found in the dev-utilities include folder.\u000A// e.g., $ONEAPI_ROOT/dev-utilities//include/dpc_common.hpp\u000A#include \"dpc_common.hpp\"\u000A#if FPGA || FPGA_EMULATOR\u000A  #include <sycl/ext/intel/fpga_extensions.hpp>\u000A#endif\u000A\u000Ausing namespace sycl;\u000Ausing namespace std;\u000A\u000A// Matrix size constants.\u000A// The number of hidden states N.\u000Aconstexpr int N = 20;\u000A// The number of possible observations M.\u000Aconstexpr int M = 20;\u000A// The lenght of the hidden states sequence T.\u000Aconstexpr int T = 20;\u000A// The parameter for generating the sequence.\u000Aconstexpr int seed = 0;\u000A// Minimal double to initialize  logarithms for Viterbi values equal to 0.\u000Aconstexpr double MIN_DOUBLE = -1.0 * std::numeric_limits<double>::max();\u000A    double value_min=10000;\u000A    double value_max=-1110;\u000A\u000Abool ViterbiCondition(double x, double y, double z, double compare);\u000A\u000Aint main(int argc, char* argv[]) {\u000A#if FPGA_EMULATOR\u000A  // DPC++ extension: FPGA emulator selector on systems without FPGA card.\u000A  ext::intel::fpga_emulator_selector d_selector;\u000A#elif FPGA\u000A  // DPC++ extension: FPGA selector on systems with FPGA card.\u000A  ext::intel::fpga_selector d_selector;\u000A#else\u000A  // The default device selector will select the most performant device.\u000A  default_selector d_selector;\u000A#endif\u000A      std::string file;\u000A  if (argc > 1) file = argv[1];\u000A      std::ifstream read(file);\u000A  if (!read.is_open()){\u000A      std::cout << \"Could not open the input file.\\n\";\u000A  } \u000A    int number;\u000A    double(*pi) = new double[N];\u000A    for (int i = 0; i < N; ++i) {\u000A      if (read>>number){\u000A        double f = number % N / N + 0.01f / N;\u000A        pi[i] = sycl::log10(f);\u000A      }\u000A      else{\u000A        pi[i] = sycl::log10(1.0f / N);\u000A      }\u000A    }\u000A   \u000A    try {\u000A    // Initializing and generating initial probabilities for the hidden states.\u000A        \u000A        buffer<double, 1> pi_buf(pi, N);\u000A        \u000A        //Device initialization.\u000A        queue q(d_selector, dpc_common::exception_handler);\u000A        cout << \"Device: \" << q.get_device().get_info<info::device::name>() << \" \"\u000A            << q.get_device().get_platform().get_info<info::platform::name>() << \"\\n\";\u000A        //Buffers initialization.\u000A        buffer<double, 2> viterbi(range<2>(N, T));\u000A        buffer<int, 2> back_pointer(range<2>(N, T));\u000A        buffer<double, 2> a(range<2>(N, N));\u000A        buffer<double, 2> b(range<2>(N, M));\u000A        \u000A        // Generating transition matrix A for the Markov process.\u000A        q.submit([&](handler& h) {\u000A            auto a_acc = a.get_access<access::mode::write>(h);\u000A            h.parallel_for(range<2>(N, N), [=](id<2> index) {\u000A                // The sum of the probabilities in each row of the matrix A  has to be equal to 1.\u000A                double prob = 1.0f / N;\u000A                // The algorithm computes logarithms of the probability values to improve small numbers processing.\u000A                a_acc[index] = sycl::log10(prob);\u000A            });\u000A        });\u000A        \u000A    \u000A        // Generating emission matrix B for the Markov process.\u000A        q.submit([&](handler& h) {\u000A            auto b_acc = b.get_access<access::mode::write>(h);\u000A            auto a_acc = a.get_access<access::mode::read>(h);\u000A            h.parallel_for(range<2>(N, M), [=](id<2> index) {\u000A                // The sum of the probabilities in each row of the matrix B has to be equal to 1.\u000A                double prob = ((index[0] + index[1]) % M) * 2.0f / M / (M - 1);\u000A                // The algorithm computes logarithms of the probability values to improve small numbers processing.\u000A                b_acc[index] = (prob == 0.0f) ? MIN_DOUBLE : a_acc[index];\u000A            });\u000A        });\u000A        \u000A\u000A        // Generating the sequence of the observations produced by the hidden Markov chain.\u000A        int(*seq) = new int[T];\u000A        for (int i = 0; i < T; ++i) {\u000A              seq[i] = (i * i + seed) % M;\u000A        }\u000A        \u000A        buffer<int, 1> seq_buf(seq, T);\u000A        buffer vmin(&value_min,range<1>(1));\u000A        buffer vmax(&value_max,range<1>(1));\u000A        // Initialization of the Viterbi matrix and the matrix of back pointers.\u000A        q.submit([&](handler& h) {\u000A            auto v_acc = viterbi.get_access<access::mode::write>(h);\u000A            auto b_ptr_acc = back_pointer.get_access<access::mode::write>(h);\u000A            auto b_acc = b.get_access<access::mode::read>(h);\u000A            auto pi_acc = pi_buf.get_access<access::mode::read>(h);\u000A            auto seq_acc = seq_buf.get_access<access::mode::read>(h);\u000A            accessor a(vmin, h, write_only);\u000A            accessor b(vmax, h, write_only);\u000A            h.parallel_for(range<2>(N, T), [=](id<2> index) {\u000A                int i = index[0];\u000A                int j = index[1];\u000A                // At starting point only the first Viterbi values are defined and these Values are substituted \u000A                // with logarithms  due to the following equation: log(x*y) = log(x) + log(y)\u000A                v_acc[index] = (j != 0) ? MIN_DOUBLE : pi_acc[i] + b_acc[i][seq_acc[0]];\u000A                // Default values of all the back pointers are (-1) to show that they are not determined yet. \u000A                b_ptr_acc[index] = -1;\u000A            });\u000A        });    \u000A\u000A        // The sequential steps of the Viterbi algorithm that define the Viterbi matrix and the matrix \u000A        // of back pointers. The product of the Viterbi values and the probabilities is substituted with the sum of \u000A        // the logarithms due to the following equation: log (x*y*z) = log(x) + log(y) + log(z).\u000A        for (int j = 0; j < T - 1; ++j) {\u000A            q.submit([&](handler& h) {\u000A                auto v_acc = viterbi.get_access<access::mode::read_write>(h);\u000A                auto b_ptr_acc = back_pointer.get_access<access::mode::read_write>(h);\u000A                auto a_acc = a.get_access <access::mode::read>(h);\u000A                auto b_acc = b.get_access <access::mode::read>(h);\u000A                auto seq_acc = seq_buf.get_access <access::mode::read>(h);\u000A\u000A                h.parallel_for(range<2>(N, N), [=](id<2> index) {\u000A                    int i = index[0], k = index[1];\u000A                    // This conditional block finds the maximum possible Viterbi value on \u000A                    // the current step j for the state i.\u000A                    if (ViterbiCondition(v_acc[k][j], b_acc[i][seq_acc[j + 1]], a_acc[k][i], v_acc[i][j + 1])) {\u000A                        v_acc[i][j + 1] = v_acc[k][j] + a_acc[k][i] + b_acc[i][seq_acc[j + 1]];\u000A                        b_ptr_acc[i][j + 1] = k;\u000A                    }\u000A                });\u000A            });\u000A        }\u000A\u000A        // Getting the Viterbi path based on the matrix of back pointers\u000A        buffer<int, 1> vit_path(range<1> {T});\u000A        auto v_acc = viterbi.get_access<access::mode::read>();\u000A        auto b_ptr_acc = back_pointer.get_access<access::mode::read>();\u000A        auto vit_path_acc = vit_path.get_access<access::mode::read_write>();\u000A        double v_max = MIN_DOUBLE;\u000A        // Constructing the Viterbi path. The last state of this path is the one with \u000A        // the biggest Viterbi value (the most likely state).\u000A        for (int i = 0; i < N; ++i) {\u000A            if (v_acc[i][T - 1] > v_max) {\u000A                v_max = v_acc[i][T - 1];\u000A                vit_path_acc[T - 1] = i;\u000A            }\u000A        }\u000A    \u000A        for (int i = T - 2; i >= 0; --i) {\u000A            // Every back pointer starting from the last one contains the index of the previous\u000A            // point in Viterbi path.\u000A            vit_path_acc[i] = b_ptr_acc[vit_path_acc[i + 1]][i + 1];\u000A        }\u000A\u000A        cout << \"The Viterbi path is: \"<< std::endl;\u000A        for (int k = 0; k < T; ++k) {\u000A            cout << vit_path_acc[k] << \" \";\u000A        }\u000A        cout << std::endl;\u000A\u000A    } catch (sycl::exception const& e) {\u000A        // Exception processing\u000A        cout << \"An exception is caught!\\n\";\u000A        cout << \"Error message:\" << e.what();\u000A        terminate();\u000A    }\u000A    cout << \"The sample completed successfully!\" << std::endl;\u000A    cout << \"Max:\"<<value_max<<std::endl<<\"Min:\"<<value_min;\u000A    std::ofstream outfile;\u000A    outfile.open(\"exec_fpga_info.txt\");\u000A    outfile << 1 << std::endl << 1 << std::endl << 1;\u000A    outfile.close();\u000A    return 0;\u000A}\u000A\u000A// The method checks if all three components of the sum are not equivalent to logarithm of zero \u000A// (that is incorrect value and is substituted with minimal possible value of double) and that \u000A// the Viterbi value on the new step exceeds the current one.\u000Abool ViterbiCondition(double x, double y, double z, double compare) {\u000A    return (x > MIN_DOUBLE) && (y > MIN_DOUBLE) && (z > MIN_DOUBLE) && (x + y + z > compare);\u000A}"}]