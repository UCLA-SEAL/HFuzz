[{"path":"/home/u93631/A10_oneapi/GSimulation/src/FakeIOPipes.hpp", "name":"FakeIOPipes.hpp", "has_active_debug_locs":false, "absName":"/home/u93631/A10_oneapi/GSimulation/src/FakeIOPipes.hpp", "content":"#ifndef __FAKEIOPIPES_HPP__\u000A#define __FAKEIOPIPES_HPP__\u000A\u000A#include <iostream>\u000A#include <type_traits>\u000A#include <utility>\u000A\u000A#include <CL/sycl.hpp>\u000A#include <sycl/ext/intel/fpga_extensions.hpp>\u000A\u000A// the \"detail\" namespace is commonly used in C++ as an internal namespace\u000A// (to a file) that is not meant to be visible to the public and should be\u000A// ignored by external users. That is to say, you should never have the line:\u000A// \"using namespace detail;\" in your code!\u000A//\u000A// \"internal\" is another common name for a namespace like this.\u000Anamespace detail {\u000A\u000Ausing namespace sycl;\u000A\u000Atemplate <typename ID, typename T, bool use_host_alloc>\u000Aclass ProducerConsumerBaseImpl {\u000A protected:\u000A  // private members\u000A  static inline T *host_data_{nullptr};\u000A  static inline T *device_data_{nullptr};\u000A  static inline size_t count_{};\u000A  static inline bool initialized_{false};\u000A\u000A  // use some fancy C++ metaprogramming to get the correct pointer type\u000A  // based on the template variable\u000A  typedef\u000A      typename std::conditional_t<use_host_alloc, host_ptr<T>, device_ptr<T>>\u000A          kernel_ptr_type;\u000A\u000A  // private constructor so users cannot make an object\u000A  ProducerConsumerBaseImpl(){};\u000A\u000A  static T *get_kernel_ptr() {\u000A    return use_host_alloc ? host_data_ : device_data_;\u000A  }\u000A\u000A  static void initialized_check() {\u000A    if (!initialized_) {\u000A      std::cerr << \"ERROR: Init() has not been called\\n\";\u000A      std::terminate();\u000A    }\u000A  }\u000A\u000A public:\u000A  // disable copy constructor and operator=\u000A  ProducerConsumerBaseImpl(const ProducerConsumerBaseImpl &) = delete;\u000A  ProducerConsumerBaseImpl &operator=(ProducerConsumerBaseImpl const &) =\u000A      delete;\u000A\u000A  static void Init(queue &q, size_t count) {\u000A    // make sure init hasn't already been called\u000A    if (initialized_) {\u000A      std::cerr << \"ERROR: Init() was already called\\n\";\u000A      std::terminate();\u000A    }\u000A\u000A    // track count\u000A    count_ = count;\u000A\u000A    // check for USM support\u000A    device d = q.get_device();\u000A    if (!d.get_info<info::device::usm_host_allocations>() && use_host_alloc) {\u000A      std::cerr << \"ERROR: The selected device does not support USM host\"\u000A                << \" allocations\\n\";\u000A      std::terminate();\u000A    }\u000A    if (!d.get_info<info::device::usm_device_allocations>()) {\u000A      std::cerr << \"ERROR: The selected device does not support USM device\"\u000A                << \" allocations\\n\";\u000A      std::terminate();\u000A    }\u000A\u000A    // Allocate the space the user requested. Calling a different malloc\u000A    // based on whether the user wants to use USM host allocations or not.\u000A    if (use_host_alloc) {\u000A      host_data_ = malloc_host<T>(count_, q);\u000A    } else {\u000A      host_data_ = new T[count_];\u000A    }\u000A\u000A    if (host_data_ == nullptr) {\u000A      std::cerr << \"ERROR: failed to allocate space for host_data_\\n\";\u000A      std::terminate();\u000A    }\u000A\u000A    // if not using host allocations, allocate device memory\u000A    if (!use_host_alloc) {\u000A      device_data_ = malloc_device<T>(count_, q);\u000A      if (device_data_ == nullptr) {\u000A        std::cerr << \"ERROR: failed to allocate space for\"\u000A                  << \"device_data_\\n\";\u000A        std::terminate();\u000A      }\u000A    }\u000A\u000A    initialized_ = true;\u000A  }\u000A\u000A  static void Destroy(queue &q) {\u000A    initialized_check();\u000A\u000A    // free memory depending on 'use_host_alloc' flag\u000A    if (use_host_alloc) {\u000A      // free USM host allocation\u000A      sycl::free(host_data_, q);\u000A    } else {\u000A      // free C++ allocated memory\u000A      delete[] host_data_;\u000A\u000A      // free USM device allocation\u000A      sycl::free(device_data_, q);\u000A    }\u000A\u000A    initialized_ = false;\u000A  }\u000A\u000A  static size_t Count() {\u000A    initialized_check();\u000A    return count_;\u000A  }\u000A\u000A  static T *Data() {\u000A    initialized_check();\u000A    return host_data_;\u000A  }\u000A};\u000A\u000A////////////////////////////////////////////////////////////////////////////////\u000A// Producer implementation\u000Atemplate <typename Id, typename T, bool use_host_alloc, size_t min_capacity>\u000Aclass ProducerImpl : public ProducerConsumerBaseImpl<Id, T, use_host_alloc> {\u000A private:\u000A  // base implementation alias\u000A  using BaseImpl = ProducerConsumerBaseImpl<Id, T, use_host_alloc>;\u000A  using kernel_ptr_type = typename BaseImpl::kernel_ptr_type;\u000A\u000A  // IDs for the pipe and kernel\u000A  class PipeID;\u000A  class KernelID;\u000A\u000A  // private constructor so users cannot make an object\u000A  ProducerImpl(){};\u000A\u000A public:\u000A  // disable copy constructor and operator=\u000A  ProducerImpl(const ProducerImpl &) = delete;\u000A  ProducerImpl &operator=(ProducerImpl const &) = delete;\u000A\u000A  // the pipe to connect to in device code\u000A  using Pipe = sycl::ext::intel::pipe<PipeID, T, min_capacity>;\u000A\u000A  // the implementation of the static\u000A  static std::pair<event, event> Start(queue &q,\u000A                                       size_t count = BaseImpl::count_) {\u000A    // make sure initialized has been called\u000A    BaseImpl::initialized_check();\u000A\u000A    // can't produce more data than exists\u000A    if (count > BaseImpl::count_) {\u000A      std::cerr << \"ERROR: Start() called with count=\" << count\u000A                << \" but allocated size is \" << BaseImpl::count_ << \"\\n\";\u000A      std::terminate();\u000A    }\u000A\u000A    // If we aren't using USM host allocations, must transfer memory to device\u000A    event dma_event;\u000A    if (!use_host_alloc) {\u000A      dma_event = q.memcpy(BaseImpl::device_data_, BaseImpl::host_data_,\u000A                           BaseImpl::count_ * sizeof(T));\u000A    }\u000A\u000A    // pick the right pointer to pass to the kernel\u000A    auto kernel_ptr = BaseImpl::get_kernel_ptr();\u000A\u000A    // launch the kernel (use event.depends_on to wait on the memcpy)\u000A    auto kernel_event = q.submit([&](handler &h) {\u000A      // the kernel must wait until the DMA transfer is done before launching\u000A      // this will only take affect it we actually performed the DMA above\u000A      h.depends_on(dma_event);\u000A\u000A      // the producing kernel\u000A      // NO-FORMAT comments are for clang-format\u000A      h.single_task<Id>([=\u000A      ]() [[intel::kernel_args_restrict]] {  // NO-FORMAT: Attribute\u000A        kernel_ptr_type ptr(kernel_ptr);\u000A        for (size_t i = 0; i < count; i++) {\u000A          auto d = *(ptr + i);\u000A          Pipe::write(d);\u000A        }\u000A      });\u000A    });\u000A\u000A    return std::make_pair(dma_event, kernel_event);\u000A  }\u000A};\u000A////////////////////////////////////////////////////////////////////////////////\u000A\u000A////////////////////////////////////////////////////////////////////////////////\u000A// Consumer implementation\u000Atemplate <typename Id, typename T, bool use_host_alloc, size_t min_capacity>\u000Aclass ConsumerImpl : public ProducerConsumerBaseImpl<Id, T, use_host_alloc> {\u000A private:\u000A  // base implementation alias\u000A  using BaseImpl = ProducerConsumerBaseImpl<Id, T, use_host_alloc>;\u000A  using kernel_ptr_type = typename BaseImpl::kernel_ptr_type;\u000A\u000A  // IDs for the pipe and kernel\u000A  class PipeID;\u000A  class KernelID;\u000A\u000A  // private constructor so users cannot make an object\u000A  ConsumerImpl(){};\u000A\u000A public:\u000A  // disable copy constructor and operator=\u000A  ConsumerImpl(const ConsumerImpl &) = delete;\u000A  ConsumerImpl &operator=(ConsumerImpl const &) = delete;\u000A\u000A  // the pipe to connect to in device code\u000A  using Pipe = sycl::ext::intel::pipe<PipeID, T, min_capacity>;\u000A\u000A  static std::pair<event, event> Start(queue &q,\u000A                                       size_t count = BaseImpl::count_) {\u000A    // make sure initialized has been called\u000A    BaseImpl::initialized_check();\u000A\u000A    // can't produce more data than exists\u000A    if (count > BaseImpl::count_) {\u000A      std::cerr << \"ERROR: Start() called with count=\" << count\u000A                << \" but allocated size is \" << BaseImpl::count_ << \"\\n\";\u000A      std::terminate();\u000A    }\u000A\u000A    // pick the right pointer to pass to the kernel\u000A    auto kernel_ptr = BaseImpl::get_kernel_ptr();\u000A\u000A    // launch the kernel to read the output into device side global memory\u000A    auto kernel_event = q.submit([&](handler &h) {\u000A      // NO-FORMAT comments are for clang-format\u000A      h.single_task<Id>([=\u000A      ]() [[intel::kernel_args_restrict]] {  // NO-FORMAT: Attribute\u000A        kernel_ptr_type ptr(kernel_ptr);\u000A        for (size_t i = 0; i < count; i++) {\u000A          auto d = Pipe::read();\u000A          *(ptr + i) = d;\u000A        }\u000A      });\u000A    });\u000A\u000A    // if the user wanted to use board memory, copy the data back to the host\u000A    event dma_event;\u000A    if (!use_host_alloc) {\u000A      // launch a task to copy the data back from the device. Use the\u000A      // event.depends_on signal to wait for the kernel to finish first.\u000A      dma_event = q.submit([&](handler &h) {\u000A        h.depends_on(kernel_event);\u000A        h.memcpy(BaseImpl::host_data_, BaseImpl::device_data_,\u000A                 BaseImpl::count_ * sizeof(T));\u000A      });\u000A    }\u000A\u000A    return std::make_pair(dma_event, kernel_event);\u000A  }\u000A};\u000A////////////////////////////////////////////////////////////////////////////////\u000A\u000A}  // namespace detail\u000A\u000A// alias the implementations to face the user\u000Atemplate <typename Id, typename T, bool use_host_alloc, size_t min_capacity = 0>\u000Ausing Producer = detail::ProducerImpl<Id, T, use_host_alloc, min_capacity>;\u000A\u000Atemplate <typename Id, typename T, bool use_host_alloc, size_t min_capacity = 0>\u000Ausing Consumer = detail::ConsumerImpl<Id, T, use_host_alloc, min_capacity>;\u000A\u000A// convenient aliases to get a host or device allocation producer/consumer\u000Atemplate <typename Id, typename T, size_t min_capacity = 0>\u000Ausing HostConsumer = Consumer<Id, T, true, min_capacity>;\u000A\u000Atemplate <typename Id, typename T, size_t min_capacity = 0>\u000Ausing DeviceConsumer = Consumer<Id, T, false, min_capacity>;\u000A\u000Atemplate <typename Id, typename T, size_t min_capacity = 0>\u000Ausing HostProducer = Producer<Id, T, true, min_capacity>;\u000A\u000Atemplate <typename Id, typename T, size_t min_capacity = 0>\u000Ausing DeviceProducer = Producer<Id, T, false, min_capacity>;\u000A\u000A#endif /* __FAKEIOPIPES_HPP__ */\u000A"}, {"path":"/home/u93631/A10_oneapi/GSimulation/src/GSimulation.hpp", "name":"GSimulation.hpp", "has_active_debug_locs":false, "absName":"/home/u93631/A10_oneapi/GSimulation/src/GSimulation.hpp", "content":"//==============================================================\u000A// Copyright © 2020 Intel Corporation\u000A//\u000A// SPDX-License-Identifier: MIT\u000A// =============================================================\u000A\u000A#ifndef _GSIMULATION_HPP\u000A#define _GSIMULATION_HPP\u000A\u000A//#include <CL/sycl.hpp>\u000A#include <cstdlib>\u000A#include <fstream>\u000A#include <iomanip>\u000A#include <iostream>\u000A#include <random>\u000A#include <sstream>\u000A#include <string>\u000A#include <vector>\u000A\u000A#include \"Particle.hpp\"\u000A\u000Aclass GSimulation {\u000A public:\u000A  GSimulation();\u000A\u000A  void Init();\u000A  void SetNumberOfParticles(int N);\u000A  void SetNumberOfSteps(int N);\u000A  void Start(std::string file);\u000A\u000A private:\u000A  //  Particle *particles_;\u000A  std::vector<Particle> particles_;\u000A  int npart_;       // number of particles\u000A  int nsteps_;      // number of integration steps\u000A  RealType tstep_;  // time step of the simulation\u000A\u000A  int sfreq_;  // sample frequency\u000A\u000A  RealType kenergy_;  // kinetic energy\u000A\u000A  double total_time_;   // total time of the simulation\u000A  double total_flops_;  // total number of FLOPS\u000A\u000A  void InitPos(std::string file);\u000A  void InitVel();\u000A  void InitAcc();\u000A  void InitMass();\u000A\u000A  void set_npart(const int &N) { npart_ = N; }\u000A  int get_npart() const { return npart_; }\u000A\u000A  void set_tstep(const RealType &dt) { tstep_ = dt; }\u000A  RealType get_tstep() const { return tstep_; }\u000A\u000A  void set_nsteps(const int &n) { nsteps_ = n; }\u000A  int get_nsteps() const { return nsteps_; }\u000A\u000A  void set_sfreq(const int &sf) { sfreq_ = sf; }\u000A  int get_sfreq() const { return sfreq_; }\u000A\u000A  void PrintHeader();\u000A};\u000A\u000A#endif"}, {"path":"/home/u93631/A10_oneapi/GSimulation/src/GSimulation_noprob_kernel_variable.cpp", "name":"GSimulation_noprob_kernel_variable.cpp", "has_active_debug_locs":false, "absName":"/home/u93631/A10_oneapi/GSimulation/src/GSimulation_noprob_kernel_variable.cpp", "content":" //==============================================================\u000A// Copyright © 2020 Intel Corporation\u000A//\u000A// SPDX-License-Identifier: MIT\u000A// =============================================================\u000A\u000A#include \"GSimulation.hpp\"\u000A\u000A// dpc_common.hpp can be found in the dev-utilities include folder.\u000A// e.g., $ONEAPI_ROOT/dev-utilities/latest/include/dpc_common.hpp\u000A#include \"dpc_common.hpp\"\u000A#include \"FakeIOPipes.hpp\"\u000A#include \"HostSideChannel.hpp\"\u000A#if FPGA || FPGA_EMULATOR\u000A  #include <sycl/ext/intel/fpga_extensions.hpp>\u000A#endif\u000A\u000Astruct DeviceToHostSideChannelID;\u000Astruct SideChannelMainKernel;\u000A\u000A\u000Ausing namespace sycl;\u000A\u000A    // Create device selector for the device of your interest.\u000A#if FPGA_EMULATOR\u000A  // DPC++ extension: FPGA emulator selector on systems without FPGA card.\u000A  ext::intel::fpga_emulator_selector d_selector;\u000A#elif FPGA\u000A  // DPC++ extension: FPGA selector on systems with FPGA card.\u000A  ext::intel::fpga_selector d_selector;\u000A#else\u000A  // The default device selector will select the most performant device.\u000A  default_selector d_selector;\u000A#endif\u000A\u000A/* Default Constructor for the GSimulation class which sets up the default\u000A * values for number of particles, number of integration steps, time steo and\u000A * sample frequency */\u000AGSimulation::GSimulation() {\u000A  std::cout << \"===============================\"\u000A            << \"\\n\";\u000A  std::cout << \" Initialize Gravity Simulation\"\u000A            << \"\\n\";\u000A  set_npart(16000);\u000A  set_nsteps(10);\u000A  set_tstep(0.1);\u000A  set_sfreq(1);\u000A}\u000A\u000A/* Set the number of particles */\u000Avoid GSimulation::SetNumberOfParticles(int N) { set_npart(N); }\u000A\u000A/* Set the number of integration steps */\u000Avoid GSimulation::SetNumberOfSteps(int N) { set_nsteps(N); }\u000A\u000A/* Initialize the position of all the particles using random number generator\u000A * between 0 and 1.0 */\u000Avoid GSimulation::InitPos(std::string file) {\u000A  \u000A  std::ifstream read(file);\u000A  if (!read.is_open()){\u000A      std::cout << \"Could not open the input file.\\n\";\u000A  } \u000A    \u000A  std::random_device rd;  // random number generator\u000A  std::mt19937 gen(42);\u000A  std::uniform_real_distribution<RealType> unif_d(0, 1.0);\u000A\u000A  for (int i = 0; i < get_npart(); ++i) {\u000A    float number;\u000A    particles_[i].pos[0] = unif_d(gen);\u000A    particles_[i].pos[1] = unif_d(gen);\u000A    particles_[i].pos[2] = unif_d(gen);\u000A    if (read >> number){\u000A        particles_[i].pos[0] = number;\u000A    }\u000A    if (read >> number){\u000A        particles_[i].pos[1] = number;\u000A    }\u000A    if (read >> number){\u000A        particles_[i].pos[2] = number;\u000A    }\u000A  }\u000A}\u000A\u000A/* Initialize the velocity of all the particles using random number generator\u000A * between -1.0 and 1.0 */\u000Avoid GSimulation::InitVel() {\u000A  std::random_device rd;  // random number generator\u000A  std::mt19937 gen(42);\u000A  std::uniform_real_distribution<RealType> unif_d(-1.0, 1.0);\u000A\u000A  for (int i = 0; i < get_npart(); ++i) {\u000A    particles_[i].vel[0] = unif_d(gen) * 1.0e-3f;\u000A    particles_[i].vel[1] = unif_d(gen) * 1.0e-3f;\u000A    particles_[i].vel[2] = unif_d(gen) * 1.0e-3f;\u000A  }\u000A}\u000A\u000A/* Initialize the acceleration of all the particles to 0 */\u000Avoid GSimulation::InitAcc() {\u000A  for (int i = 0; i < get_npart(); ++i) {\u000A    particles_[i].acc[0] = 0.f;\u000A    particles_[i].acc[1] = 0.f;\u000A    particles_[i].acc[2] = 0.f;\u000A  }\u000A}\u000A\u000A\u000A/* Initialize the mass of all the particles using a random number generator\u000A * between 0 and 1 */\u000Avoid GSimulation::InitMass() {\u000A  RealType n = static_cast<RealType>(get_npart());\u000A  std::random_device rd;  // random number generator\u000A  std::mt19937 gen(42);\u000A  std::uniform_real_distribution<RealType> unif_d(0.0, 1.0);\u000A\u000A  for (int i = 0; i < get_npart(); ++i) {\u000A    particles_[i].mass = n * unif_d(gen);\u000A  }\u000A}\u000A\u000A/* This function does the simulation logic for Nbody */\u000Avoid GSimulation::Start(std::string file) {\u000A  RealType dt = get_tstep();\u000A  int n = get_npart();\u000A  particles_.resize(n);\u000A  \u000A  \u000A  InitPos(file);\u000A  InitVel();\u000A  InitAcc();\u000A  InitMass();\u000A\u000A  PrintHeader();\u000A\u000A  total_time_ = 0.;\u000A\u000A  float kSofteningSquared = 1e-14f;\u000A  // prevents explosion in the case the particles are really close to each other\u000A  float kG = 6.67259e-11f;\u000A  double gflops = 1e-9 * ((11. + 18.) * n * n + n * 19.);\u000A  int nf = 0;\u000A  double av = 0.0, dev = 0.0;\u000A  // Create global range\u000A  auto r = range<1>(n);\u000A  // Create local range\u000A  auto lr = range<1>(128);\u000A  // Create ndrange \u000A  auto ndrange = nd_range<1>(r, lr);\u000A  // Create a queue to the selected device and enabled asynchronous exception\u000A  // handling for that queue\u000A  queue q(d_selector, dpc_common::exception_handler);\u000A  // Create SYCL buffer for the Particle array of size \"n\"\u000A    buffer pbuf(particles_.data(), r,\u000A              {cl::sycl::property::buffer::use_host_ptr()});\u000A  // Allocate energy using USM allocator shared\u000A  RealType *energy = malloc_shared<RealType>(1,q);\u000A  *energy = 0.f;\u000A\u000A  float acc_max = 0;\u000A  float acc_min = 0;\u000A  dpc_common::TimeInterval t0;\u000A  int nsteps = get_nsteps();\u000A  // Looping across integration steps\u000A  for (int s = 1; s <= nsteps; ++s) {\u000A    \u000A    dpc_common::TimeInterval ts0;\u000A    // Submitting first kernel to device which computes acceleration of all\u000A    // particles\u000A     q.submit([&](handler& h) {\u000A       auto p = pbuf.get_access(h);\u000A       h.parallel_for(ndrange, [=](nd_item<1> it) {\u000A\t auto i = it.get_global_id();\u000A         RealType acc_max = 0;\u000A         RealType acc_min = 0;\u000A         RealType acc0 = 0;\u000A         RealType acc1 = 0;\u000A         RealType acc2 = 0;\u000A         for (int j = 0; j < n; j++) {\u000A           RealType dx, dy, dz;\u000A           RealType distance_sqr = 0.0f;\u000A           RealType distance_inv = 0.0f;\u000A\u000A           dx = p[j].pos[0] - p[i].pos[0];  // 1flop\u000A           dy = p[j].pos[1] - p[i].pos[1];  // 1flop\u000A           dz = p[j].pos[2] - p[i].pos[2];  // 1flop\u000A\u000A           distance_sqr =\u000A               dx * dx + dy * dy + dz * dz+ kSofteningSquared;  // 6flops\u000A           distance_inv = 1.0f / sycl::sqrt(distance_sqr);       // 1div+1sqrt\u000A\u000A           if (dx==0) {acc0=0;}\u000A           else{\u000A             acc0 += dx * kG * p[j].mass * distance_inv * distance_inv *\u000A                   distance_inv;  // 6flops\u000A             \u000A           }\u000A           if (dy==0) {acc1=0;}\u000A           else{\u000A           acc1 += dy * kG * p[j].mass * distance_inv * distance_inv *\u000A                   distance_inv;  // 6flops\u000A           }\u000A           if (dz==0){acc2=0;}\u000A           else{\u000A           acc2 += dz * kG * p[j].mass * distance_inv * distance_inv *\u000A                   distance_inv;  // 6flops\u000A           }\u000A           if (acc1>acc_max) {acc_max=acc1;}\u000A           if (acc2>acc_max) {acc_max=acc2;}\u000A           if (acc0>acc_max) {acc_max=acc0;}\u000A             \u000A           if (acc1<acc_min) {acc_min=acc1;}\u000A           if (acc2<acc_min) {acc_min=acc2;}\u000A           if (acc0<acc_min) {acc_min=acc0;}\u000A         }\u000A         p[i].acc[0] = acc0;\u000A         p[i].acc[1] = acc1;\u000A         p[i].acc[2] = acc2;\u000A           \u000A         p[i].vel[0] += acc0 * dt;  // 2flops\u000A         p[i].vel[1] += acc1 * dt;  // 2flops\u000A         p[i].vel[2] += acc2 * dt;  // 2flops\u000A       });\u000A     }).wait_and_throw();\u000A    // Second kernel updates the velocity and position for all particles\u000A      \u000A    q.submit([&](handler& h) {\u000A       auto p = pbuf.get_access(h);\u000A       h.parallel_for(ndrange, [=](nd_item<1> it) {\u000A\t    auto i = it.get_global_id();\u000A\u000A         p[i].pos[0] += p[i].vel[0] * dt;  // 2flops\u000A        p[i].pos[1] += p[i].vel[1] * dt;  // 2flops\u000A         p[i].pos[2] += p[i].vel[2] * dt;  // 2flops\u000A\u000A         energy[0] += (p[i].mass *\u000A                (p[i].vel[0] * p[i].vel[0] + p[i].vel[1] * p[i].vel[1] +\u000A                 p[i].vel[2] * p[i].vel[2]));  // 7flops\u000A       });\u000A     }).wait_and_throw();\u000A      \u000A    kenergy_ = 0.5 * (*energy);\u000A    *energy = 0.f;\u000A    double elapsed_seconds = ts0.Elapsed();\u000A    if ((s % get_sfreq()) == 0) {\u000A      nf += 1;\u000A      std::cout << \" \" << std::left << std::setw(8) << s << std::left\u000A                << std::setprecision(5) << std::setw(8) << s * get_tstep()\u000A                << std::left << std::setprecision(5) << std::setw(12)\u000A                << kenergy_ << std::left << std::setprecision(5)\u000A                << std::setw(12) << elapsed_seconds << std::left\u000A                << std::setprecision(5) << std::setw(12)\u000A                << gflops * get_sfreq() / elapsed_seconds << \"\\n\";\u000A      if (nf > 2) {\u000A        av += gflops * get_sfreq() / elapsed_seconds;\u000A        dev += gflops * get_sfreq() * gflops * get_sfreq() /\u000A               (elapsed_seconds * elapsed_seconds);\u000A      }\u000A    }\u000A\u000A    for (int i=0; i<n; i++){\u000A        if (particles_[i].acc[0]>acc_max) {acc_max=particles_[i].acc[0];}\u000A        if (particles_[i].acc[1]>acc_max) {acc_max=particles_[i].acc[1];}\u000A        if (particles_[i].acc[2]>acc_max) {acc_max=particles_[i].acc[2];}\u000A             \u000A        if (particles_[i].acc[0]<acc_min) {acc_min=particles_[i].acc[0];}\u000A        if (particles_[i].acc[1]<acc_min) {acc_min=particles_[i].acc[1];}\u000A        if (particles_[i].acc[2]<acc_min) {acc_min=particles_[i].acc[2];}\u000A    }\u000A    if (-acc_min>acc_max) {acc_max = -acc_min;}\u000A  }  // end of the time step loop\u000A  total_time_ = t0.Elapsed();\u000A  total_flops_ = gflops * get_nsteps();\u000A  av /= (double)(nf - 2);\u000A  dev = sqrt(dev / (double)(nf - 2) - av * av);\u000A  std::cout <<\"\\n\";\u000A  std::cout << \"# Total Time (s)     : \" << total_time_ << \"\\n\";\u000A  std::cout << \"# Average Performance : \" << av << \" +- \" << dev << \"\\n\";\u000A  std::cout << \"===============================\"\u000A            << \"\\n\";\u000A  std::ofstream outfile;\u000A  outfile.open(\"exec_fpga_info.txt\");\u000A  outfile << acc_max << std::endl << acc_max << std::endl;\u000A  outfile.close();\u000A}\u000A\u000A/* Print the headers for the output */\u000Avoid GSimulation::PrintHeader() {\u000A  std::cout << \" nPart = \" << get_npart() << \"; \"\u000A            << \"nSteps = \" << get_nsteps() << \"; \"\u000A            << \"dt = \" << get_tstep() << \"\\n\";\u000A\u000A  std::cout << \"------------------------------------------------\"\u000A            << \"\\n\";\u000A  std::cout << \" \" << std::left << std::setw(8) << \"s\" << std::left\u000A            << std::setw(8) << \"dt\" << std::left << std::setw(12) << \"kenergy\"\u000A            << std::left << std::setw(12) << \"time (s)\" << std::left\u000A            << std::setw(12) << \"GFLOPS\"\u000A            << \"\\n\";\u000A  std::cout << \"------------------------------------------------\"\u000A            << \"\\n\";\u000A}\u000A\u000A             \u000Aint main(int argc, char** argv) {\u000A  int n;      // number of particles\u000A  int nstep;  // number ot integration steps\u000A\u000A  GSimulation sim;\u000A\u000A#ifdef DEBUG\u000A  char* env = std::getenv(\"SYCL_BE\");\u000A  std::cout << \"[ENV] SYCL_BE = \" << (env ? env : \"<not set>\") << \"\\n\";\u000A#endif\u000A  std::string file;\u000A  if (argc > 1) {\u000A    //n = std::atoi(argv[1]);\u000A    //sim.SetNumberOfParticles(n);\u000A    file = argv[1];\u000A    if (argc == 3) {\u000A      nstep = std::atoi(argv[2]);\u000A      sim.SetNumberOfSteps(nstep);\u000A    }\u000A  }\u000A\u000A  sim.Start(file);\u000A\u000A  return 0;\u000A}"}, {"path":"/home/u93631/A10_oneapi/GSimulation/src/HostSideChannel.hpp", "name":"HostSideChannel.hpp", "has_active_debug_locs":false, "absName":"/home/u93631/A10_oneapi/GSimulation/src/HostSideChannel.hpp", "content":"#ifndef __HOSTSIDECHANNEL_HPP__\u000A#define __HOSTSIDECHANNEL_HPP__\u000A\u000A#include <iostream>\u000A#include <type_traits>\u000A\u000A#include <CL/sycl.hpp>\u000A#include <sycl/ext/intel/fpga_extensions.hpp>\u000A\u000A#include \"FakeIOPipes.hpp\"\u000A\u000Ausing namespace sycl;\u000A\u000A//\u000A// This class provides a convenient, but low-bandwidth and relatively high\u000A// latency, side channel to send data from the host to the device. It exposes\u000A// a read() interface to the DEVICE code that the user can treat just like a\u000A// SYCL pipe. It also exposes a write interface to the HOST that allows the\u000A// user to easily write data from host to the device\u000A//\u000Atemplate <typename Id, typename T, bool use_host_alloc, size_t min_capacity=0>\u000Aclass HostToDeviceSideChannel {\u000Aprotected:\u000A  using MyProducer = Producer<Id, T, use_host_alloc, min_capacity>;\u000A  static inline queue* q_{nullptr};\u000A\u000Apublic:\u000A  // disable copy constructor and operator=\u000A  HostToDeviceSideChannel()=delete;\u000A  HostToDeviceSideChannel(const HostToDeviceSideChannel &)=delete;\u000A  HostToDeviceSideChannel& operator=(HostToDeviceSideChannel const &)=delete;\u000A\u000A  static void Init(queue &q) {\u000A    q_ = &q;\u000A    MyProducer::Init(q, 1);\u000A  };\u000A\u000A  static void Destroy(queue &q) {\u000A    q_ = nullptr;\u000A    MyProducer::Destroy(q);\u000A  };\u000A\u000A  static T read() {\u000A    // DEVICE CODE\u000A    return MyProducer::Pipe::read();\u000A  }\u000A\u000A  static T read(bool &success_code) {\u000A    // DEVICE CODE\u000A    return MyProducer::Pipe::read(success_code);\u000A  }\u000A\u000A  // blocking\u000A  static void write(const T &data) {\u000A    // HOST CODE\u000A    // populate the data\u000A    MyProducer::Data()[0] = data;\u000A\u000A    // start the kernel and wait on it to finish (blocking)\u000A    event dma, kernel;\u000A    std::tie(dma, kernel) = MyProducer::Start(*q_);\u000A    dma.wait();\u000A    kernel.wait();\u000A  }\u000A\u000A  // non-blocking\u000A  // Call .wait() on the returned event to wait for the write to take place\u000A  static event write(const T &data, bool &success_code) {\u000A    // HOST CODE\u000A    // always succeed\u000A    success_code = true;\u000A\u000A    // populate the data\u000A    MyProducer::Data()[0] = data;\u000A\u000A    // start the kernel and return the kernel event\u000A    return MyProducer::Start(*q_).second;\u000A  }\u000A};\u000A\u000A//\u000A// This class provides a convenient, but not highly performing, side channel\u000A// to send data from the device to the host. It exposes a read() interface\u000A// to the HOST code that lets the user get updates from the device.\u000A// It also exposes a write interface to the DEVICE that allows the user to\u000A// easily write data from device to the host.\u000A//\u000Atemplate <typename Id, typename T, bool use_host_alloc, size_t min_capacity=0>\u000Aclass DeviceToHostSideChannel {\u000Aprotected:\u000A  using MyConsumer = Consumer<Id, T, use_host_alloc, min_capacity>;\u000A  static inline queue* q_{nullptr};\u000A\u000Apublic:\u000A  // disable copy constructor and operator=\u000A  DeviceToHostSideChannel()=delete;\u000A  DeviceToHostSideChannel(const DeviceToHostSideChannel &)=delete;\u000A  DeviceToHostSideChannel& operator=(DeviceToHostSideChannel const &)=delete;\u000A\u000A  static void Init(queue &q) {\u000A    q_ = &q;\u000A    MyConsumer::Init(q, 1);\u000A  };\u000A\u000A  static void Destroy(queue &q) {\u000A    q_ = nullptr;\u000A    MyConsumer::Destroy(q);\u000A  };\u000A\u000A  // blocking\u000A  static T read() {\u000A    // HOST CODE\u000A    // launch the kernel to read the data from the pipe into memory\u000A    // and wait for it to finish (blocking)\u000A    event dma, kernel;\u000A    std::tie(dma, kernel) = MyConsumer::Start(*q_);\u000A    dma.wait();\u000A    kernel.wait();\u000A\u000A    // the kernel has finished, so return the data\u000A    return MyConsumer::Data()[0];\u000A  }\u000A\u000A  // non-blocking\u000A  // call .wait() on the returned event to wait for the read to take place,\u000A  // then access the data using ::Data()[0]\u000A  static event read(bool &success_code) {\u000A    // start the kernel and return the event\u000A    // the user can use ::Data() later to get the data\u000A    // return the DMA event, since it happen second\u000A    success_code = true;\u000A    return MyConsumer::Start(*q_).first;\u000A  }\u000A\u000A  static void write(const T &data) {\u000A    // DEVICE CODE\u000A    MyConsumer::Pipe::write(data);\u000A  }\u000A\u000A  static void write(const T &data, bool &success_code) {\u000A    // DEVICE CODE\u000A    MyConsumer::Pipe::write(data, success_code);\u000A  }\u000A\u000A  static T Data() {\u000A    return MyConsumer::Data()[0];\u000A  }\u000A};\u000A\u000A#endif /* __HOSTSIDECHANNEL_HPP__ */\u000A"}, {"path":"/home/u93631/A10_oneapi/GSimulation/src/Particle.hpp", "name":"Particle.hpp", "has_active_debug_locs":false, "absName":"/home/u93631/A10_oneapi/GSimulation/src/Particle.hpp", "content":"#ifndef _PARTICLE_HPP\u000A#define _PARTICLE_HPP\u000A#include <cmath>\u000A\u000A#include \"type.hpp\"\u000A\u000Astruct Particle {\u000A public:\u000A  Particle() : pos{}, vel{}, acc{}, mass{} {};\u000A  RealType pos[3];\u000A  RealType vel[3];\u000A  RealType acc[3];\u000A  RealType mass;\u000A};\u000A\u000A#endif"}, {"path":"/glob/development-tools/versions/oneapi/2022.3/oneapi/dev-utilities/2021.7.0/include/dpc_common.hpp", "name":"dpc_common.hpp", "has_active_debug_locs":false, "absName":"/glob/development-tools/versions/oneapi/2022.3/oneapi/dev-utilities/2021.7.0/include/dpc_common.hpp", "content":"// Copyright (C) 2020 Intel Corporation\u000A// SPDX-License-Identifier: MIT\u000A\u000A#ifndef _DP_HPP\u000A#define _DP_HPP\u000A\u000A#include <stdlib.h>\u000A#include <exception>\u000A\u000A#include <CL/sycl.hpp>\u000A\u000Anamespace dpc_common {\u000A// This exception handler will catch async exceptions\u000Astatic auto exception_handler = [](cl::sycl::exception_list eList) {\u000A  for (std::exception_ptr const &e : eList) {\u000A    try {\u000A      std::rethrow_exception(e);\u000A    } catch (std::exception const &e) {\u000A#if _DEBUG\u000A      std::cout << \"Failure\" << std::endl;\u000A#endif\u000A      std::terminate();\u000A    }\u000A  }\u000A};\u000A\u000A// The TimeInterval is a simple RAII class.\u000A// Construct the timer at the point you want to start timing.\u000A// Use the Elapsed() method to return time since construction.\u000A\u000Aclass TimeInterval {\u000A public:\u000A  TimeInterval() : start_(std::chrono::steady_clock::now()) {}\u000A\u000A  double Elapsed() {\u000A    auto now = std::chrono::steady_clock::now();\u000A    return std::chrono::duration_cast<Duration>(now - start_).count();\u000A  }\u000A\u000A private:\u000A  using Duration = std::chrono::duration<double>;\u000A  std::chrono::steady_clock::time_point start_;\u000A};\u000A\u000A};  // namespace dpc_common\u000A\u000A#endif\u000A"}, {"path":"/home/u93631/A10_oneapi/GSimulation/src/type.hpp", "name":"type.hpp", "has_active_debug_locs":false, "absName":"/home/u93631/A10_oneapi/GSimulation/src/type.hpp", "content":"using RealType = float;"}]