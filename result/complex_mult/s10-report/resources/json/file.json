[{"path":"/home/u93631/A10_oneapi/complex_mult/src/Complex.hpp", "name":"Complex.hpp", "has_active_debug_locs":false, "absName":"/home/u93631/A10_oneapi/complex_mult/src/Complex.hpp", "content":"//==============================================================\u000A// Copyright � 2020 Intel Corporation\u000A//\u000A// SPDX-License-Identifier: MIT\u000A// =============================================================\u000A\u000A#include <iostream>\u000A#include <vector>\u000Ausing namespace std;\u000Aclass Complex2 {\u000A private:\u000A  int m_real_, m_imag_;\u000A\u000A public:\u000A  Complex2() {\u000A    m_real_ = 0;\u000A    m_imag_ = 0;\u000A  }\u000A  Complex2(int x, int y) {\u000A    m_real_ = x;\u000A    m_imag_ = y;\u000A  }\u000A    \u000A  int real() const{\u000A      return m_real_;\u000A  }\u000A    \u000A  int imag() const{\u000A      return m_imag_;\u000A  }\u000A\u000A  // Overloading the  != operator\u000A  friend bool operator!=(const Complex2& a, const Complex2& b) {\u000A    return (a.m_real_ != b.m_real_) || (a.m_imag_ != b.m_imag_);\u000A  }\u000A\u000A  // The function performs Complex number multiplication and returns a Complex2\u000A  // object.\u000A  Complex2 complex_mul(const Complex2& obj) const{\u000A    return Complex2(((m_real_ * obj.m_real_) - (m_imag_ * obj.m_imag_)),\u000A                    ((m_real_ * obj.m_imag_) + (m_imag_ * obj.m_real_)));\u000A  }\u000A  \u000A  bool complex_limit() const{\u000A      if ((m_real_ > 1<<30) or (m_imag_ > 1<<30)) {\u000A          return false;\u000A      }\u000A      return true;\u000A  }\u000A  // Overloading the ostream operator to print the objects of the Complex2\u000A  // object\u000A  friend ostream& operator<<(ostream& out, const Complex2& obj) {\u000A    out << \"(\" << obj.m_real_ << \" : \" << obj.m_imag_ << \"i)\";\u000A    return out;\u000A  }\u000A};\u000A"}, {"path":"/home/u93631/A10_oneapi/complex_mult/src/FakeIOPipes.hpp", "name":"FakeIOPipes.hpp", "has_active_debug_locs":false, "absName":"/home/u93631/A10_oneapi/complex_mult/src/FakeIOPipes.hpp", "content":"#ifndef __FAKEIOPIPES_HPP__\u000A#define __FAKEIOPIPES_HPP__\u000A\u000A#include <iostream>\u000A#include <type_traits>\u000A#include <utility>\u000A\u000A#include <CL/sycl.hpp>\u000A#include <sycl/ext/intel/fpga_extensions.hpp>\u000A\u000A// the \"detail\" namespace is commonly used in C++ as an internal namespace\u000A// (to a file) that is not meant to be visible to the public and should be\u000A// ignored by external users. That is to say, you should never have the line:\u000A// \"using namespace detail;\" in your code!\u000A//\u000A// \"internal\" is another common name for a namespace like this.\u000Anamespace detail {\u000A\u000Ausing namespace sycl;\u000A\u000Atemplate <typename ID, typename T, bool use_host_alloc>\u000Aclass ProducerConsumerBaseImpl {\u000A protected:\u000A  // private members\u000A  static inline T *host_data_{nullptr};\u000A  static inline T *device_data_{nullptr};\u000A  static inline size_t count_{};\u000A  static inline bool initialized_{false};\u000A\u000A  // use some fancy C++ metaprogramming to get the correct pointer type\u000A  // based on the template variable\u000A  typedef\u000A      typename std::conditional_t<use_host_alloc, host_ptr<T>, device_ptr<T>>\u000A          kernel_ptr_type;\u000A\u000A  // private constructor so users cannot make an object\u000A  ProducerConsumerBaseImpl(){};\u000A\u000A  static T *get_kernel_ptr() {\u000A    return use_host_alloc ? host_data_ : device_data_;\u000A  }\u000A\u000A  static void initialized_check() {\u000A    if (!initialized_) {\u000A      std::cerr << \"ERROR: Init() has not been called\\n\";\u000A      std::terminate();\u000A    }\u000A  }\u000A\u000A public:\u000A  // disable copy constructor and operator=\u000A  ProducerConsumerBaseImpl(const ProducerConsumerBaseImpl &) = delete;\u000A  ProducerConsumerBaseImpl &operator=(ProducerConsumerBaseImpl const &) =\u000A      delete;\u000A\u000A  static void Init(queue &q, size_t count) {\u000A    // make sure init hasn't already been called\u000A    if (initialized_) {\u000A      std::cerr << \"ERROR: Init() was already called\\n\";\u000A      std::terminate();\u000A    }\u000A\u000A    // track count\u000A    count_ = count;\u000A\u000A    // check for USM support\u000A    device d = q.get_device();\u000A    if (!d.get_info<info::device::usm_host_allocations>() && use_host_alloc) {\u000A      std::cerr << \"ERROR: The selected device does not support USM host\"\u000A                << \" allocations\\n\";\u000A      std::terminate();\u000A    }\u000A    if (!d.get_info<info::device::usm_device_allocations>()) {\u000A      std::cerr << \"ERROR: The selected device does not support USM device\"\u000A                << \" allocations\\n\";\u000A      std::terminate();\u000A    }\u000A\u000A    // Allocate the space the user requested. Calling a different malloc\u000A    // based on whether the user wants to use USM host allocations or not.\u000A    if (use_host_alloc) {\u000A      host_data_ = malloc_host<T>(count_, q);\u000A    } else {\u000A      host_data_ = new T[count_];\u000A    }\u000A\u000A    if (host_data_ == nullptr) {\u000A      std::cerr << \"ERROR: failed to allocate space for host_data_\\n\";\u000A      std::terminate();\u000A    }\u000A\u000A    // if not using host allocations, allocate device memory\u000A    if (!use_host_alloc) {\u000A      device_data_ = malloc_device<T>(count_, q);\u000A      if (device_data_ == nullptr) {\u000A        std::cerr << \"ERROR: failed to allocate space for\"\u000A                  << \"device_data_\\n\";\u000A        std::terminate();\u000A      }\u000A    }\u000A\u000A    initialized_ = true;\u000A  }\u000A\u000A  static void Destroy(queue &q) {\u000A    initialized_check();\u000A\u000A    // free memory depending on 'use_host_alloc' flag\u000A    if (use_host_alloc) {\u000A      // free USM host allocation\u000A      sycl::free(host_data_, q);\u000A    } else {\u000A      // free C++ allocated memory\u000A      delete[] host_data_;\u000A\u000A      // free USM device allocation\u000A      sycl::free(device_data_, q);\u000A    }\u000A\u000A    initialized_ = false;\u000A  }\u000A\u000A  static size_t Count() {\u000A    initialized_check();\u000A    return count_;\u000A  }\u000A\u000A  static T *Data() {\u000A    initialized_check();\u000A    return host_data_;\u000A  }\u000A};\u000A\u000A////////////////////////////////////////////////////////////////////////////////\u000A// Producer implementation\u000Atemplate <typename Id, typename T, bool use_host_alloc, size_t min_capacity>\u000Aclass ProducerImpl : public ProducerConsumerBaseImpl<Id, T, use_host_alloc> {\u000A private:\u000A  // base implementation alias\u000A  using BaseImpl = ProducerConsumerBaseImpl<Id, T, use_host_alloc>;\u000A  using kernel_ptr_type = typename BaseImpl::kernel_ptr_type;\u000A\u000A  // IDs for the pipe and kernel\u000A  class PipeID;\u000A  class KernelID;\u000A\u000A  // private constructor so users cannot make an object\u000A  ProducerImpl(){};\u000A\u000A public:\u000A  // disable copy constructor and operator=\u000A  ProducerImpl(const ProducerImpl &) = delete;\u000A  ProducerImpl &operator=(ProducerImpl const &) = delete;\u000A\u000A  // the pipe to connect to in device code\u000A  using Pipe = sycl::ext::intel::pipe<PipeID, T, min_capacity>;\u000A\u000A  // the implementation of the static\u000A  static std::pair<event, event> Start(queue &q,\u000A                                       size_t count = BaseImpl::count_) {\u000A    // make sure initialized has been called\u000A    BaseImpl::initialized_check();\u000A\u000A    // can't produce more data than exists\u000A    if (count > BaseImpl::count_) {\u000A      std::cerr << \"ERROR: Start() called with count=\" << count\u000A                << \" but allocated size is \" << BaseImpl::count_ << \"\\n\";\u000A      std::terminate();\u000A    }\u000A\u000A    // If we aren't using USM host allocations, must transfer memory to device\u000A    event dma_event;\u000A    if (!use_host_alloc) {\u000A      dma_event = q.memcpy(BaseImpl::device_data_, BaseImpl::host_data_,\u000A                           BaseImpl::count_ * sizeof(T));\u000A    }\u000A\u000A    // pick the right pointer to pass to the kernel\u000A    auto kernel_ptr = BaseImpl::get_kernel_ptr();\u000A\u000A    // launch the kernel (use event.depends_on to wait on the memcpy)\u000A    auto kernel_event = q.submit([&](handler &h) {\u000A      // the kernel must wait until the DMA transfer is done before launching\u000A      // this will only take affect it we actually performed the DMA above\u000A      h.depends_on(dma_event);\u000A\u000A      // the producing kernel\u000A      // NO-FORMAT comments are for clang-format\u000A      h.single_task<Id>([=\u000A      ]() [[intel::kernel_args_restrict]] {  // NO-FORMAT: Attribute\u000A        kernel_ptr_type ptr(kernel_ptr);\u000A        for (size_t i = 0; i < count; i++) {\u000A          auto d = *(ptr + i);\u000A          Pipe::write(d);\u000A        }\u000A      });\u000A    });\u000A\u000A    return std::make_pair(dma_event, kernel_event);\u000A  }\u000A};\u000A////////////////////////////////////////////////////////////////////////////////\u000A\u000A////////////////////////////////////////////////////////////////////////////////\u000A// Consumer implementation\u000Atemplate <typename Id, typename T, bool use_host_alloc, size_t min_capacity>\u000Aclass ConsumerImpl : public ProducerConsumerBaseImpl<Id, T, use_host_alloc> {\u000A private:\u000A  // base implementation alias\u000A  using BaseImpl = ProducerConsumerBaseImpl<Id, T, use_host_alloc>;\u000A  using kernel_ptr_type = typename BaseImpl::kernel_ptr_type;\u000A\u000A  // IDs for the pipe and kernel\u000A  class PipeID;\u000A  class KernelID;\u000A\u000A  // private constructor so users cannot make an object\u000A  ConsumerImpl(){};\u000A\u000A public:\u000A  // disable copy constructor and operator=\u000A  ConsumerImpl(const ConsumerImpl &) = delete;\u000A  ConsumerImpl &operator=(ConsumerImpl const &) = delete;\u000A\u000A  // the pipe to connect to in device code\u000A  using Pipe = sycl::ext::intel::pipe<PipeID, T, min_capacity>;\u000A\u000A  static std::pair<event, event> Start(queue &q,\u000A                                       size_t count = BaseImpl::count_) {\u000A    // make sure initialized has been called\u000A    BaseImpl::initialized_check();\u000A\u000A    // can't produce more data than exists\u000A    if (count > BaseImpl::count_) {\u000A      std::cerr << \"ERROR: Start() called with count=\" << count\u000A                << \" but allocated size is \" << BaseImpl::count_ << \"\\n\";\u000A      std::terminate();\u000A    }\u000A\u000A    // pick the right pointer to pass to the kernel\u000A    auto kernel_ptr = BaseImpl::get_kernel_ptr();\u000A\u000A    // launch the kernel to read the output into device side global memory\u000A    auto kernel_event = q.submit([&](handler &h) {\u000A      // NO-FORMAT comments are for clang-format\u000A      h.single_task<Id>([=\u000A      ]() [[intel::kernel_args_restrict]] {  // NO-FORMAT: Attribute\u000A        kernel_ptr_type ptr(kernel_ptr);\u000A        for (size_t i = 0; i < count; i++) {\u000A          auto d = Pipe::read();\u000A          *(ptr + i) = d;\u000A        }\u000A      });\u000A    });\u000A\u000A    // if the user wanted to use board memory, copy the data back to the host\u000A    event dma_event;\u000A    if (!use_host_alloc) {\u000A      // launch a task to copy the data back from the device. Use the\u000A      // event.depends_on signal to wait for the kernel to finish first.\u000A      dma_event = q.submit([&](handler &h) {\u000A        h.depends_on(kernel_event);\u000A        h.memcpy(BaseImpl::host_data_, BaseImpl::device_data_,\u000A                 BaseImpl::count_ * sizeof(T));\u000A      });\u000A    }\u000A\u000A    return std::make_pair(dma_event, kernel_event);\u000A  }\u000A};\u000A////////////////////////////////////////////////////////////////////////////////\u000A\u000A}  // namespace detail\u000A\u000A// alias the implementations to face the user\u000Atemplate <typename Id, typename T, bool use_host_alloc, size_t min_capacity = 0>\u000Ausing Producer = detail::ProducerImpl<Id, T, use_host_alloc, min_capacity>;\u000A\u000Atemplate <typename Id, typename T, bool use_host_alloc, size_t min_capacity = 0>\u000Ausing Consumer = detail::ConsumerImpl<Id, T, use_host_alloc, min_capacity>;\u000A\u000A// convenient aliases to get a host or device allocation producer/consumer\u000Atemplate <typename Id, typename T, size_t min_capacity = 0>\u000Ausing HostConsumer = Consumer<Id, T, true, min_capacity>;\u000A\u000Atemplate <typename Id, typename T, size_t min_capacity = 0>\u000Ausing DeviceConsumer = Consumer<Id, T, false, min_capacity>;\u000A\u000Atemplate <typename Id, typename T, size_t min_capacity = 0>\u000Ausing HostProducer = Producer<Id, T, true, min_capacity>;\u000A\u000Atemplate <typename Id, typename T, size_t min_capacity = 0>\u000Ausing DeviceProducer = Producer<Id, T, false, min_capacity>;\u000A\u000A#endif /* __FAKEIOPIPES_HPP__ */\u000A"}, {"path":"/home/u93631/A10_oneapi/complex_mult/src/HostSideChannel.hpp", "name":"HostSideChannel.hpp", "has_active_debug_locs":false, "absName":"/home/u93631/A10_oneapi/complex_mult/src/HostSideChannel.hpp", "content":"#ifndef __HOSTSIDECHANNEL_HPP__\u000A#define __HOSTSIDECHANNEL_HPP__\u000A\u000A#include <iostream>\u000A#include <type_traits>\u000A\u000A#include <CL/sycl.hpp>\u000A#include <sycl/ext/intel/fpga_extensions.hpp>\u000A\u000A#include \"FakeIOPipes.hpp\"\u000A\u000Ausing namespace sycl;\u000A\u000A//\u000A// This class provides a convenient, but low-bandwidth and relatively high\u000A// latency, side channel to send data from the host to the device. It exposes\u000A// a read() interface to the DEVICE code that the user can treat just like a\u000A// SYCL pipe. It also exposes a write interface to the HOST that allows the\u000A// user to easily write data from host to the device\u000A//\u000Atemplate <typename Id, typename T, bool use_host_alloc, size_t min_capacity=0>\u000Aclass HostToDeviceSideChannel {\u000Aprotected:\u000A  using MyProducer = Producer<Id, T, use_host_alloc, min_capacity>;\u000A  static inline queue* q_{nullptr};\u000A\u000Apublic:\u000A  // disable copy constructor and operator=\u000A  HostToDeviceSideChannel()=delete;\u000A  HostToDeviceSideChannel(const HostToDeviceSideChannel &)=delete;\u000A  HostToDeviceSideChannel& operator=(HostToDeviceSideChannel const &)=delete;\u000A\u000A  static void Init(queue &q) {\u000A    q_ = &q;\u000A    MyProducer::Init(q, 1);\u000A  };\u000A\u000A  static void Destroy(queue &q) {\u000A    q_ = nullptr;\u000A    MyProducer::Destroy(q);\u000A  };\u000A\u000A  static T read() {\u000A    // DEVICE CODE\u000A    return MyProducer::Pipe::read();\u000A  }\u000A\u000A  static T read(bool &success_code) {\u000A    // DEVICE CODE\u000A    return MyProducer::Pipe::read(success_code);\u000A  }\u000A\u000A  // blocking\u000A  static void write(const T &data) {\u000A    // HOST CODE\u000A    // populate the data\u000A    MyProducer::Data()[0] = data;\u000A\u000A    // start the kernel and wait on it to finish (blocking)\u000A    event dma, kernel;\u000A    std::tie(dma, kernel) = MyProducer::Start(*q_);\u000A    dma.wait();\u000A    kernel.wait();\u000A  }\u000A\u000A  // non-blocking\u000A  // Call .wait() on the returned event to wait for the write to take place\u000A  static event write(const T &data, bool &success_code) {\u000A    // HOST CODE\u000A    // always succeed\u000A    success_code = true;\u000A\u000A    // populate the data\u000A    MyProducer::Data()[0] = data;\u000A\u000A    // start the kernel and return the kernel event\u000A    return MyProducer::Start(*q_).second;\u000A  }\u000A};\u000A\u000A//\u000A// This class provides a convenient, but not highly performing, side channel\u000A// to send data from the device to the host. It exposes a read() interface\u000A// to the HOST code that lets the user get updates from the device.\u000A// It also exposes a write interface to the DEVICE that allows the user to\u000A// easily write data from device to the host.\u000A//\u000Atemplate <typename Id, typename T, bool use_host_alloc, size_t min_capacity=0>\u000Aclass DeviceToHostSideChannel {\u000Aprotected:\u000A  using MyConsumer = Consumer<Id, T, use_host_alloc, min_capacity>;\u000A  static inline queue* q_{nullptr};\u000A\u000Apublic:\u000A  // disable copy constructor and operator=\u000A  DeviceToHostSideChannel()=delete;\u000A  DeviceToHostSideChannel(const DeviceToHostSideChannel &)=delete;\u000A  DeviceToHostSideChannel& operator=(DeviceToHostSideChannel const &)=delete;\u000A\u000A  static void Init(queue &q) {\u000A    q_ = &q;\u000A    MyConsumer::Init(q, 1);\u000A  };\u000A\u000A  static void Destroy(queue &q) {\u000A    q_ = nullptr;\u000A    MyConsumer::Destroy(q);\u000A  };\u000A\u000A  // blocking\u000A  static T read() {\u000A    // HOST CODE\u000A    // launch the kernel to read the data from the pipe into memory\u000A    // and wait for it to finish (blocking)\u000A    event dma, kernel;\u000A    std::tie(dma, kernel) = MyConsumer::Start(*q_);\u000A    dma.wait();\u000A    kernel.wait();\u000A\u000A    // the kernel has finished, so return the data\u000A    return MyConsumer::Data()[0];\u000A  }\u000A\u000A  // non-blocking\u000A  // call .wait() on the returned event to wait for the read to take place,\u000A  // then access the data using ::Data()[0]\u000A  static event read(bool &success_code) {\u000A    // start the kernel and return the event\u000A    // the user can use ::Data() later to get the data\u000A    // return the DMA event, since it happen second\u000A    success_code = true;\u000A    return MyConsumer::Start(*q_).first;\u000A  }\u000A\u000A  static void write(const T &data) {\u000A    // DEVICE CODE\u000A    MyConsumer::Pipe::write(data);\u000A  }\u000A\u000A  static void write(const T &data, bool &success_code) {\u000A    // DEVICE CODE\u000A    MyConsumer::Pipe::write(data, success_code);\u000A  }\u000A\u000A  static T Data() {\u000A    return MyConsumer::Data()[0];\u000A  }\u000A};\u000A\u000A#endif /* __HOSTSIDECHANNEL_HPP__ */\u000A"}, {"path":"/home/u93631/A10_oneapi/complex_mult/src/complex_mult_nopipe_fuzz.cpp", "name":"complex_mult_nopipe_fuzz.cpp", "has_active_debug_locs":false, "absName":"/home/u93631/A10_oneapi/complex_mult/src/complex_mult_nopipe_fuzz.cpp", "content":"\u000A//==============================================================\u000A// Copyright © 2020 Intel Corporation\u000A//\u000A// SPDX-License-Identifier: MIT\u000A// =============================================================\u000A#include <CL/sycl.hpp>\u000A#include <iomanip>\u000A#include <vector>\u000A// dpc_common.hpp can be found in the dev-utilities include folder.\u000A// e.g., $ONEAPI_ROOT/dev-utilities/<version>/include/dpc_common.hpp\u000A#include \"dpc_common.hpp\"\u000A#include \"Complex.hpp\"\u000A#include \"FakeIOPipes.hpp\"\u000A#include \"HostSideChannel.hpp\"\u000A#if FPGA || FPGA_EMULATOR\u000A  #include <sycl/ext/intel/fpga_extensions.hpp>\u000A#endif\u000A//Undone\u000Ausing namespace sycl;\u000Ausing namespace std;\u000A  int a_max = 0;\u000A  int a_min = 10000000;\u000A\u000A// Number of complex numbers passing to the DPC++ code\u000Astatic const int num_elements = 100000;\u000Atypedef std::vector<int> IntVector; \u000A\u000Astruct DeviceToHostSideChannelID;\u000Astruct SideChannelMainKernel;\u000Ausing MyDeviceToHostSideChannel = DeviceToHostSideChannel<DeviceToHostSideChannelID, int, true, 8>;\u000A\u000Aclass CustomDeviceSelector : public device_selector {\u000A public:\u000A  CustomDeviceSelector(std::string vendorName) : vendorName_(vendorName){};\u000A  int operator()(const device &dev) const override {\u000A    int device_rating = 0;\u000A    // In the below code we are querying for the custom device specific to a\u000A    // Vendor and if it is a GPU device we are giving the highest rating. The\u000A    // second preference is given to any GPU device and the third preference is\u000A    // given to CPU device.\u000A    if (dev.is_gpu() & (dev.get_info<info::device::name>().find(vendorName_) !=\u000A                        std::string::npos))\u000A      device_rating = 3;\u000A    else if (dev.is_gpu())\u000A      device_rating = 2;\u000A    else if (dev.is_cpu())\u000A      device_rating = 1;\u000A    return device_rating;\u000A  };\u000A\u000A private:\u000A  std::string vendorName_;\u000A};\u000A\u000Aint write_file(const char *address, std::vector<Complex2> &a, std::vector<Complex2> &b){\u000A    FILE* f = fopen(address,\"w\");\u000A    \u000A    for (int i = 0; i < a.size(); i++) {\u000A      fprintf(f,\"%d %d\", a[i].real(), a[i].imag());\u000A    }\u000A    for (int i = 0; i < b.size(); i++) {\u000A      fprintf(f,\"%d %d\", b[i].real(), b[i].imag());\u000A    }\u000A    return 0;\u000A}\u000A\u000Avoid mutate(std::vector<Complex2> &a, int max_i){\u000A    srand(time(NULL) + rand());\u000A    int knob = rand()%4+1;\u000A\u000A    int pos_i = rand()% max_i;\u000A    \u000A    if (knob==1){\u000A        int value = rand()% 200000;\u000A        a[pos_i] = Complex2(value, value+2);\u000A    }\u000A    else if (knob==2){\u000A        a[pos_i] = Complex2(23124,12312);\u000A    }\u000A    else if (knob==3){\u000A        int max_k = rand()% (max_i - pos_i);\u000A        for (size_t k = pos_i; k < pos_i+max_k; k++){\u000A            int value = rand() % 200000;\u000A            a[k] = Complex2(value, value+2);\u000A        }\u000A    }\u000A    else if (knob==4){\u000A        for (int i = 0; i <pos_i; i++){\u000A            a[i] = Complex2(23124,12312);\u000A        }\u000A        //for (int i = 0; i < THREADS; i++)\u000A\t\t//    threads[i] = std::thread(parallel_sparsity, std::ref(a), max_k, max_i, i);\u000A\t    //for (int i = 0; i < THREADS; i++)\u000A\t\t//    threads[i].join();\u000A    }\u000A    else if (knob==5){\u000A        for (int i = 1; i < pos_i; i++){\u000A            a[i] = Complex2(a[i].real()*20+100, a[i].imag()*20+100);\u000A            if (a[i].real() > a_max){ \u000A                a_max = a[i].real();\u000A            }\u000A            if (a[i].imag() > a_max){ \u000A                a_max = a[i].imag();\u000A            }\u000A            if (a[i].real() < a_min){ \u000A                a_min = a[i].real();\u000A            }\u000A            if (a[i].imag() < a_min){ \u000A                a_min = a[i].imag();\u000A            }\u000A        }\u000A        //for (int i = 0; i < THREADS; i++)\u000A\t\t//    threads[i] = std::thread(parallel_add, std::ref(a), max_k, max_i, i);\u000A\t    //for (int i = 0; i < THREADS; i++)\u000A\t\t//    threads[i].join();\u000A    }\u000A    else if (knob==6){\u000A        for (int i = 1; i < pos_i; i++){\u000A            a[i] = Complex2(a[i].real()/20-100, a[i].imag()/20-100);\u000A            if (a[i].real() < a_min){ \u000A                a_min = a[i].real();\u000A            }\u000A            if (a[i].imag() < a_min){ \u000A                a_min = a[i].imag();\u000A            }\u000A        }\u000A        //for (int i = 0; i < THREADS; i++)\u000A\t\t//    threads[i] = std::thread(parallel_minus,std::ref(a), max_k, max_i, i);\u000A\t    //for (int i = 0; i < THREADS; i++)\u000A\t\t//    threads[i].join();\u000A    }\u000A}\u000A\u000A// in_vect1 and in_vect2 are the vectors with num_elements complex nubers and\u000A// are inputs to the parallel function\u000Avoid DpcppParallel(queue &q, std::vector<Complex2> &in_vect1,\u000A                   std::vector<Complex2> &in_vect2,\u000A                   std::vector<Complex2> &out_vect, IntVector &flag) {\u000A  auto R = range(in_vect1.size());\u000A  if (in_vect2.size() != in_vect1.size() || out_vect.size() != in_vect1.size()){ \u000A\t  std::cout << \"ERROR: Vector sizes do not  match\"<< \"\\n\";\u000A\t  return;\u000A  }\u000A  // Setup input buffers\u000A  buffer bufin_vect1(in_vect1);\u000A  buffer bufin_vect2(in_vect2);\u000A\u000A  // Setup Output buffers \u000A  buffer bufout_vect(out_vect);\u000A  buffer flagout(flag);\u000A  std::cout << \"Target Device: \"\u000A            << q.get_device().get_info<info::device::name>() << \"\\n\";\u000A  // Submit Command group function object to the queue\u000A  q.submit([&](auto &h) {\u000A    // Accessors set as read mode\u000A    accessor V1(bufin_vect1,h,read_only);\u000A    accessor V2(bufin_vect2,h,read_only);\u000A    // Accessor set to Write mode\u000A    accessor V3 (bufout_vect,h,write_only);\u000A    accessor flagV (flagout, h ,write_only);\u000A    h.parallel_for(R, [=](auto i) {\u000A      // call the complex_mul function that computes the multiplication of the\u000A      // complex number\u000A      V3[i] = V1[i].complex_mul(V2[i]);\u000A    });\u000A  });\u000A  q.wait_and_throw();\u000A}\u000Avoid DpcppScalar(std::vector<Complex2> &in_vect1,\u000A                 std::vector<Complex2> &in_vect2,\u000A                 std::vector<Complex2> &out_vect) {\u000A  if ((in_vect2.size() != in_vect1.size()) || (out_vect.size() != in_vect1.size())){\u000A\t  std::cout<<\"ERROR: Vector sizes do not match\"<<\"\\n\";\u000A\t  return;\u000A  }\t\t \u000A  for (int i = 0; i < in_vect1.size(); i++) {\u000A    out_vect[i] = in_vect1[i].complex_mul(in_vect2[i]);\u000A  }\u000A}\u000A// Compare the results of the two output vectors from parallel and scalar. They\u000A// should be equal\u000Aint Compare(std::vector<Complex2> &v1, std::vector<Complex2> &v2) {\u000A  int ret_code = 1;\u000A  if(v1.size() != v2.size()){\u000A\t  ret_code = -1;\u000A  }\u000A  for (int i = 0; i < v1.size(); i++) {\u000A    if (v1[i] != v2[i]) {\u000A      std::cout<<\"Error:\"<<i<<\"\\n\";\u000A      std::cout << v1[i] << \" / \" << v2[i] << \"\\n\";\u000A      ret_code = i;\u000A      break;\u000A    }\u000A  }\u000A  return ret_code;\u000A}\u000A\u000A\u000Aint main(int argc, char* argv[]) {\u000A  // Declare your Input and Output vectors of the Complex2 class\u000A  vector<Complex2> input_vect1;\u000A  vector<Complex2> input_vect2;\u000A  vector<Complex2> out_vect_parallel;\u000A  vector<Complex2> out_vect_scalar;\u000A  \u000A  IntVector sum_f, flag;\u000A  int file_number = 0;\u000A  sum_f.resize(2);\u000A  flag.resize(100);\u000A  for (int i = 0; i < 100; i++) flag[i] = 0;\u000A  \u000A  std::string file;\u000A  if (argc > 1) file = argv[1];\u000A  std::ifstream read(file);\u000A      \u000A  if (!read.is_open()){\u000A      std::cout << \"Could not open the input file.\\n\";\u000A  } \u000A  int number;\u000A  int i = 0;\u000A  while ((read >> number) and (i<num_elements)){\u000A    input_vect1.push_back(Complex2(number, number + 2));\u000A    if (number>a_max) a_max = number;\u000A    if (number<a_min) a_min = number;\u000A    i = i + 1;\u000A  }\u000A  while (i<num_elements){\u000A      input_vect1.push_back(Complex2(i, i+2));\u000A      i = i + 1;\u000A  }\u000A \u000A  i = 0;\u000A  int b_max = 0;\u000A  int b_min = 10000000;\u000A  while ((read >> number) and (i<num_elements)){\u000A    input_vect2.push_back(Complex2(number, number + 2));\u000A    if (number>b_max) b_max = number;\u000A    if (number<b_min) b_min = number;\u000A    i = i + 1;\u000A  }\u000A    \u000A  while (i<num_elements){\u000A      input_vect2.push_back(Complex2(i, i+2));\u000A      i = i + 1;\u000A  }\u000A\u000A  for (int i = 0; i < num_elements; i++) {\u000A    out_vect_parallel.push_back(Complex2(0, 0));\u000A    out_vect_scalar.push_back(Complex2(0, 0));\u000A  }\u000A  #if FPGA_EMULATOR\u000A  // DPC++ extension: FPGA emulator selector on systems without FPGA card.\u000A    ext::intel::fpga_emulator_selector d_selector;\u000A  #else\u000A    std::string vendor_name = \"Intel\";\u000A    CustomDeviceSelector d_selector(vendor_name);\u000A  #endif  \u000A  // Initialize your Input and Output Vectors. Inputs are initialized as below.\u000A  // Outputs are initialized with 0\u000A  try {\u000A    // Pass in the name of the vendor for which the device you want to query\u000A    //std::string vendor_name = \"Intel\";\u000A    // std::string vendor_name = \"AMD\";\u000A    // std::string vendor_name = \"Nvidia\";\u000A    // queue constructor passed exception handler\u000A    //CustomDeviceSelector selector(vendor_name);\u000A    queue q(d_selector, dpc_common::exception_handler);\u000A    for (int i = 0; i < 50; i++){\u000A        mutate(input_vect1, num_elements);\u000A        mutate(input_vect2, num_elements);\u000A        \u000A        sum_f[0] = 0;\u000A    // Call the DpcppParallel with the required inputs and outputs\u000A        std::cout<<\"start execution.\\n\";\u000A        DpcppParallel(q, input_vect1, input_vect2, out_vect_parallel, sum_f);\u000A        \u000A        int interested = 0;\u000A        std::cout<<sum_f[0]<<\" Overflow were found.\\n\";\u000A        std::cout<<\"finish reading.\\n\";\u000A        std::cout<<\"start destroying the channel.\\n\";\u000A        std::cout<<\"finish destroying.\\n\";\u000A        if (interested == 1){\u000A          std::string path_to_output(\"../../HeteroFuzz/prototype/good-outputs\");\u000A          \u000A          DpcppScalar(input_vect1, input_vect2, out_vect_scalar);\u000A          int result = Compare(out_vect_parallel, out_vect_scalar);\u000A          if (result == 1) {\u000A              write_file((path_to_output+\"/-prob\"+std::to_string(file_number)).c_str(), input_vect1, input_vect2);\u000A          } else write_file((path_to_output+\"/-bug\"+std::to_string(file_number)).c_str(), input_vect1, input_vect2);\u000A          file_number++;\u000A        }\u000A        \u000A    }\u000A  } catch (...) {\u000A    // some other exception detected\u000A    std::cout << \"Failure\" << std::endl;\u000A    std::terminate();\u000A  }\u000A\u000A  std::cout\u000A      << \"****************************************Multiplying Complex numbers \"\u000A         \"in Parallel********************************************************\"\u000A      << std::endl;\u000A  // Print the outputs of the Parallel function\u000A  int indices[]{0, 1, 2, 3, (num_elements - 1)};\u000A  constexpr size_t indices_size = sizeof(indices) / sizeof(int);\u000A\u000A  for (int i = 0; i < indices_size; i++) {\u000A    int j = indices[i];\u000A    if (i == indices_size - 1) std::cout << \"...\\n\";\u000A    std::cout << \"[\" << j << \"] \" << input_vect1[j] << \" * \" << input_vect2[j]\u000A              << \" = \" << out_vect_parallel[j] << \"\\n\";\u000A  }\u000A    \u000A  // Call the DpcppScalar function with the required input and outputs\u000A  DpcppScalar(input_vect1, input_vect2, out_vect_scalar);\u000A\u000A  // Compare the outputs from the parallel and the scalar functions. They should\u000A  // be equal\u000A\u000A  int ret_code = Compare(out_vect_parallel, out_vect_scalar);\u000A  std::cout << \"[\" << ret_code << \"] \" << input_vect1[ret_code] << \" * \" << input_vect2[ret_code]\u000A              << \" = \" << out_vect_parallel[ret_code] << \"\\n\";\u000A  if (ret_code == 1) {\u000A    std::cout << \"Complex multiplication successfully run on the device\"\u000A              << \"\\n\";\u000A  } else\u000A    std::cout\u000A        << \"*********************************************Verification Failed. Results are \"\u000A           \"not matched**************************\"\u000A        << \"\\n\";\u000A  \u000A  std::ofstream outfile;\u000A  outfile.open(\"exec_fpga_info.txt\");\u000A  outfile << a_max << std::endl << a_min << std::endl << b_max << std::endl << b_min;\u000A  outfile.close();\u000A  return 0;\u000A}\u000A"}, {"path":"/glob/development-tools/versions/oneapi/2022.3/oneapi/dev-utilities/2021.7.0/include/dpc_common.hpp", "name":"dpc_common.hpp", "has_active_debug_locs":false, "absName":"/glob/development-tools/versions/oneapi/2022.3/oneapi/dev-utilities/2021.7.0/include/dpc_common.hpp", "content":"// Copyright (C) 2020 Intel Corporation\u000A// SPDX-License-Identifier: MIT\u000A\u000A#ifndef _DP_HPP\u000A#define _DP_HPP\u000A\u000A#include <stdlib.h>\u000A#include <exception>\u000A\u000A#include <CL/sycl.hpp>\u000A\u000Anamespace dpc_common {\u000A// This exception handler will catch async exceptions\u000Astatic auto exception_handler = [](cl::sycl::exception_list eList) {\u000A  for (std::exception_ptr const &e : eList) {\u000A    try {\u000A      std::rethrow_exception(e);\u000A    } catch (std::exception const &e) {\u000A#if _DEBUG\u000A      std::cout << \"Failure\" << std::endl;\u000A#endif\u000A      std::terminate();\u000A    }\u000A  }\u000A};\u000A\u000A// The TimeInterval is a simple RAII class.\u000A// Construct the timer at the point you want to start timing.\u000A// Use the Elapsed() method to return time since construction.\u000A\u000Aclass TimeInterval {\u000A public:\u000A  TimeInterval() : start_(std::chrono::steady_clock::now()) {}\u000A\u000A  double Elapsed() {\u000A    auto now = std::chrono::steady_clock::now();\u000A    return std::chrono::duration_cast<Duration>(now - start_).count();\u000A  }\u000A\u000A private:\u000A  using Duration = std::chrono::duration<double>;\u000A  std::chrono::steady_clock::time_point start_;\u000A};\u000A\u000A};  // namespace dpc_common\u000A\u000A#endif\u000A"}]